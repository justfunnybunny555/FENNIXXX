-- ════════════════════════════════════════════════════════════════
-- КОНФИГУРАЦИЯ И ФУНКЦИИ
-- ════════════════════════════════════════════════════════════════
-- Этот файл содержит весь Config, ESP, Aimbot и другие функции


local Config = {
    Enabled = true,
    HitPart = "HumanoidRootPart",
    FOVSize = 80,
    TeamCheck = false,
    KnockedCheck = false,
    WallCheck = false,
    VisibleCheck = false,
    MaxDistance = 500,
    Keybind = Enum.KeyCode.C,
    Resolver = false,
    ShowFOV = false,
    RapidFire = false,
    RapidFireDelay = 0.05,
    Multipoint = false,
    MultipointSize = 1,
    ShowTargeting = false,
    
    UpdateRate = 1,
    MaxPlayersToCheck = 15,
    UseSpatialOptimization = true,
    
    GUISize = {Width = 650, Height = 800},
    GUIToggleKey = Enum.KeyCode.Insert,
    
    GUIColor = Color3.fromRGB(245, 245, 250),
    GUITransparency = 0.05,
    AccentColor = Color3.fromRGB(0, 122, 255),
    
    CurrentWeapon = nil,
    CurrentPrediction = Vector3.new(0, 0, 0),
    CurrentMaxDistance = 400,
    
    ESP = {
        Enabled = false,
        ShowBox = false,
        ShowName = false,
        ShowDistance = false,
        ShowHealth = false,
        ShowSkeleton = false,
        BoxColor = Color3.fromRGB(0, 122, 255),
        NameColor = Color3.fromRGB(255, 255, 255),
        DistanceColor = Color3.fromRGB(142, 142, 147),
        HealthBarColor = Color3.fromRGB(52, 199, 89),
        SkeletonColor = Color3.fromRGB(0, 122, 255),
        MaxDistance = 500,
        TeamCheck = false
    }
}

local SpreadMod = {
    BulletSpread = {
        Enabled = true,
        Amount = 70
    }
}

local allBodyParts = {
    "Head",
    "UpperTorso",
    "LowerTorso",
    "HumanoidRootPart",
    "LeftUpperArm",
    "LeftLowerArm",
    "LeftHand",
    "RightUpperArm",
    "RightLowerArm",
    "RightHand",
    "LeftUpperLeg",
    "LeftLowerLeg",
    "LeftFoot",
    "RightUpperLeg",
    "RightLowerLeg",
    "RightFoot"
}

local skeletonConnections = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"}
}

local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 2
FOVCircle.Color = Color3.fromRGB(0, 122, 255)
FOVCircle.Transparency = 1
FOVCircle.NumSides = 24
FOVCircle.Filled = false

local TargetIndicator = Drawing.new("Circle")
TargetIndicator.Visible = false
TargetIndicator.Thickness = 3
TargetIndicator.Color = Color3.fromRGB(52, 199, 89)
TargetIndicator.Transparency = 1
TargetIndicator.NumSides = 16
TargetIndicator.Radius = 8
TargetIndicator.Filled = false

local MultipointCircle = Drawing.new("Circle")
MultipointCircle.Visible = false
MultipointCircle.Thickness = 1
MultipointCircle.Color = Color3.fromRGB(0, 122, 255)
MultipointCircle.Transparency = 0.5
MultipointCircle.NumSides = 12
MultipointCircle.Radius = 5
MultipointCircle.Filled = false

local cachedTarget = nil
local cachedTargetPoint = nil
local lastShotTime = 0
local rapidFireConnection = nil

local playerCache = {}
local lastCacheUpdate = 0
local CACHE_UPDATE_INTERVAL = 0.5

local mouseLocation = Vector2.new(0, 0)

local currentWeaponCache = nil
local lastWeaponCheck = 0
local WEAPON_CHECK_INTERVAL = 0.2

local ESPObjects = {}

local function createESP(player)
    if ESPObjects[player] then return end
    
    local esp = {
        Box = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthBar = Drawing.new("Square"),
        HealthBarOutline = Drawing.new("Square"),
        SkeletonLines = {}
    }
    
    for i = 1, #skeletonConnections do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Thickness = 2
        line.Transparency = 1
        table.insert(esp.SkeletonLines, line)
    end
    
    esp.Box.Visible = false
    esp.Box.Thickness = 2
    esp.Box.Filled = false
    esp.Box.Transparency = 1
    
    esp.Name.Visible = false
    esp.Name.Center = true
    esp.Name.Outline = true
    esp.Name.Size = 14
    esp.Name.Font = 2
    
    esp.Distance.Visible = false
    esp.Distance.Center = true
    esp.Distance.Outline = true
    esp.Distance.Size = 13
    esp.Distance.Font = 2
    
    esp.HealthBar.Visible = false
    esp.HealthBar.Filled = true
    esp.HealthBar.Thickness = 1
    
    esp.HealthBarOutline.Visible = false
    esp.HealthBarOutline.Filled = false
    esp.HealthBarOutline.Thickness = 1
    esp.HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
    
    ESPObjects[player] = esp
end

local function removeESP(player)
    if ESPObjects[player] then
        for _, drawing in pairs(ESPObjects[player]) do
            if type(drawing) == "table" then
                for _, line in pairs(drawing) do
                    pcall(function() line:Remove() end)
                end
            else
                pcall(function() drawing:Remove() end)
            end
        end
        ESPObjects[player] = nil
    end
end

local function updateESP()
    if not Config.ESP.Enabled then
        for _, esp in pairs(ESPObjects) do
            for key, drawing in pairs(esp) do
                if key == "SkeletonLines" then
                    for _, line in pairs(drawing) do
                        line.Visible = false
                    end
                else
                    drawing.Visible = false
                end
            end
        end
        return
    end
    
    for player, esp in pairs(ESPObjects) do
        pcall(function()
            if player and player.Character and player ~= LocalPlayer then
                local character = player.Character
                local hrp = character:FindFirstChild("HumanoidRootPart")
                local head = character:FindFirstChild("Head")
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                
                if hrp and head and humanoid and humanoid.Health > 0 then
                    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                    
                    if distance <= Config.ESP.MaxDistance then
                        if Config.ESP.TeamCheck and LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team then
                            for key, drawing in pairs(esp) do
                                if key == "SkeletonLines" then
                                    for _, line in pairs(drawing) do
                                        line.Visible = false
                                    end
                                else
                                    drawing.Visible = false
                                end
                            end
                        else
                            local vector, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                            
                            if onScreen then
                                local headPos = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
                                local legPos = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0))
                                
                                local height = math.abs(headPos.Y - legPos.Y)
                                local width = height / 2
                                
                                if Config.ESP.ShowBox then
                                    esp.Box.Visible = true
                                    esp.Box.Size = Vector2.new(width, height)
                                    esp.Box.Position = Vector2.new(vector.X - width / 2, headPos.Y)
                                    esp.Box.Color = Config.ESP.BoxColor
                                else
                                    esp.Box.Visible = false
                                end
                                
                                if Config.ESP.ShowName then
                                    esp.Name.Visible = true
                                    esp.Name.Text = player.Name
                                    esp.Name.Position = Vector2.new(vector.X, headPos.Y - 20)
                                    esp.Name.Color = Config.ESP.NameColor
                                else
                                    esp.Name.Visible = false
                                end
                                
                                if Config.ESP.ShowDistance then
                                    esp.Distance.Visible = true
                                    esp.Distance.Text = math.floor(distance) .. "m"
                                    esp.Distance.Position = Vector2.new(vector.X, legPos.Y + 5)
                                    esp.Distance.Color = Config.ESP.DistanceColor
                                else
                                    esp.Distance.Visible = false
                                end
                                
                                if Config.ESP.ShowHealth then
                                    local healthPercent = humanoid.Health / humanoid.MaxHealth
                                    
                                    esp.HealthBarOutline.Visible = true
                                    esp.HealthBarOutline.Size = Vector2.new(4, height + 2)
                                    esp.HealthBarOutline.Position = Vector2.new(vector.X - width / 2 - 8, headPos.Y - 1)
                                    
                                    esp.HealthBar.Visible = true
                                    esp.HealthBar.Size = Vector2.new(2, height * healthPercent)
                                    esp.HealthBar.Position = Vector2.new(vector.X - width / 2 - 7, headPos.Y + height - height * healthPercent)
                                    esp.HealthBar.Color = Color3.fromRGB(
                                        math.clamp(255 * (1 - healthPercent), 0, 255),
                                        math.clamp(255 * healthPercent, 0, 255),
                                        0
                                    )
                                else
                                    esp.HealthBar.Visible = false
                                    esp.HealthBarOutline.Visible = false
                                end
                                
                                if Config.ESP.ShowSkeleton then
                                    for i, connection in ipairs(skeletonConnections) do
                                        local part1 = character:FindFirstChild(connection[1])
                                        local part2 = character:FindFirstChild(connection[2])
                                        
                                        if part1 and part2 and esp.SkeletonLines[i] then
                                            local pos1, vis1 = Camera:WorldToViewportPoint(part1.Position)
                                            local pos2, vis2 = Camera:WorldToViewportPoint(part2.Position)
                                            
                                            if vis1 and vis2 then
                                                esp.SkeletonLines[i].Visible = true
                                                esp.SkeletonLines[i].From = Vector2.new(pos1.X, pos1.Y)
                                                esp.SkeletonLines[i].To = Vector2.new(pos2.X, pos2.Y)
                                                esp.SkeletonLines[i].Color = Config.ESP.SkeletonColor
                                            else
                                                esp.SkeletonLines[i].Visible = false
                                            end
                                        elseif esp.SkeletonLines[i] then
                                            esp.SkeletonLines[i].Visible = false
                                        end
                                    end
                                else
                                    for _, line in pairs(esp.SkeletonLines) do
                                        line.Visible = false
                                    end
                                end
                            else
                                for key, drawing in pairs(esp) do
                                    if key == "SkeletonLines" then
                                        for _, line in pairs(drawing) do
                                            line.Visible = false
                                        end
                                    else
                                        drawing.Visible = false
                                    end
                                end
                            end
                        end
                    else
                        for key, drawing in pairs(esp) do
                            if key == "SkeletonLines" then
                                for _, line in pairs(drawing) do
                                    line.Visible = false
                                end
                            else
                                drawing.Visible = false
                            end
                        end
                    end
                else
                    for key, drawing in pairs(esp) do
                        if key == "SkeletonLines" then
                            for _, line in pairs(drawing) do
                                line.Visible = false
                            end
                        else
                            drawing.Visible = false
                        end
                    end
                end
            else
                for key, drawing in pairs(esp) do
                    if key == "SkeletonLines" then
                        for _, line in pairs(drawing) do
                            line.Visible = false
                        end
                    else
                        drawing.Visible = false
                    end
                end
            end
        end)
    end
end

Services.Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)

Services.Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)

for _, player in ipairs(Services.Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createESP(player)
    end
end

local function getCurrentWeapon()
    local now = tick()
    if now - lastWeaponCheck < WEAPON_CHECK_INTERVAL and currentWeaponCache then
        return currentWeaponCache
    end
    
    lastWeaponCheck = now
    local character = LocalPlayer.Character
    if not character then
        currentWeaponCache = nil
        return nil
    end
    
    local tool = character:FindFirstChildOfClass("Tool")
    currentWeaponCache = tool and tool.Name or nil
    return currentWeaponCache
end

local teamCheckCache = {}
local function isOnSameTeam(player)
    if not Config.TeamCheck then return false end
    if not LocalPlayer.Team or not player.Team then return false end
    
    local cacheKey = player.UserId
    local now = tick()
    
    if teamCheckCache[cacheKey] and now - teamCheckCache[cacheKey].time < 2 then
        return teamCheckCache[cacheKey].result
    end
    
    local result = LocalPlayer.Team == player.Team
    teamCheckCache[cacheKey] = {result = result, time = now}
    return result
end

local knockedCache = {}
local function isKnocked(player)
    if not Config.KnockedCheck then return false end
    
    local cacheKey = player.UserId
    local now = tick()
    
    if knockedCache[cacheKey] and now - knockedCache[cacheKey].time < 0.5 then
        return knockedCache[cacheKey].result
    end
    
    local character = player.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then
        knockedCache[cacheKey] = {result = true, time = now}
        return true
    end
    
    local bodyEffects = character:FindFirstChild("BodyEffects")
    local result = false
    if bodyEffects then
        local knocked = bodyEffects:FindFirstChild("K.O")
        if knocked and knocked.Value == true then
            result = true
        end
    end
    
    knockedCache[cacheKey] = {result = result, time = now}
    return result
end

local wallCheckCache = {}
local function hasWallBetween(origin, targetPart)
    if not Config.WallCheck then return false end
    
    local cacheKey = tostring(targetPart)
    local now = tick()
    
    if wallCheckCache[cacheKey] and now - wallCheckCache[cacheKey].time < 0.2 then
        return wallCheckCache[cacheKey].result
    end
    
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.IgnoreWater = true
    
    local direction = (targetPart.Position - origin)
    local rayResult = workspace:Raycast(origin, direction, rayParams)
    
    local result = false
    if rayResult and rayResult.Instance then
        if not rayResult.Instance:IsDescendantOf(targetPart.Parent) then
            result = true
        end
    end
    
    wallCheckCache[cacheKey] = {result = result, time = now}
    return result
end

local function isVisible(part)
    if not Config.VisibleCheck then return true end
    
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    
    return not hasWallBetween(Camera.CFrame.Position, part)
end

local function resolveVelocity(part)
    return Vector3.new(0, 0, 0)
end

local function getClosestPointOnPart(part, mousePos)
    if not Config.Multipoint then
        return part.Position
    end
    
    local size = part.Size
    local cf = part.CFrame
    
    local multipointSize = Config.MultipointSize / 10
    
    local points = {
        part.Position,
        (cf * CFrame.new(size.X * multipointSize, 0, 0)).Position,
        (cf * CFrame.new(-size.X * multipointSize, 0, 0)).Position,
        (cf * CFrame.new(0, size.Y * multipointSize, 0)).Position,
        (cf * CFrame.new(0, -size.Y * multipointSize, 0)).Position,
    }
    
    local closestPoint = part.Position
    local closestDist = math.huge
    
    for _, point in ipairs(points) do
        local screenPos, onScreen = Camera:WorldToViewportPoint(point)
        if onScreen then
            local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestPoint = point
            end
        end
    end
    
    return closestPoint
end

local function getClosestPart(character)
    if not character then return nil, nil end
    
    if Config.HitPart ~= "Closest Point" then
        local part = character:FindFirstChild(Config.HitPart)
        if part and part:IsA("BasePart") then
            local hitPoint = getClosestPointOnPart(part, mouseLocation)
            return part, hitPoint
        end
    end
    
    local bestPart, bestPoint, bestDist = nil, nil, math.huge
    
    for _, partName in ipairs(allBodyParts) do
        local part = character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            local hitPoint = getClosestPointOnPart(part, mouseLocation)
            local screenPos, onScreen = Camera:WorldToViewportPoint(hitPoint)
            
            if onScreen then
                local partPos = Vector2.new(screenPos.X, screenPos.Y)
                local dist = (mouseLocation - partPos).Magnitude
                
                if dist < bestDist then
                    bestPart = part
                    bestPoint = hitPoint
                    bestDist = dist
                end
            end
        end
    end
    
    return bestPart, bestPoint
end

local function updatePlayerCache()
    local now = tick()
    if now - lastCacheUpdate < CACHE_UPDATE_INTERVAL then return end
    lastCacheUpdate = now
    
    playerCache = {}
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myPos then return end
    
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (myPos.Position - player.Character.HumanoidRootPart.Position).Magnitude
            
            if distance <= Config.CurrentMaxDistance * 1.3 then
                table.insert(playerCache, {
                    player = player,
                    distance = distance
                })
            end
        end
    end
    
    table.sort(playerCache, function(a, b) return a.distance < b.distance end)
end

local lastTargetUpdate = 0
local TARGET_UPDATE_INTERVAL = 0.016

local function updateTarget()
    local now = tick()
    if now - lastTargetUpdate < TARGET_UPDATE_INTERVAL then return end
    lastTargetUpdate = now
    
    updatePlayerCache()
    
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        cachedTarget = nil
        cachedTargetPoint = nil
        return
    end
    
    local fovRadius = Config.FOVSize
    local bestPart, bestPoint, bestDist = nil, nil, math.huge
    
    local playersToCheck = math.min(#playerCache, Config.MaxPlayersToCheck)
    
    for i = 1, playersToCheck do
        local data = playerCache[i]
        local player = data.player
        
        if Config.TeamCheck and isOnSameTeam(player) then continue end
        if Config.KnockedCheck and isKnocked(player) then continue end
        
        local part, hitPoint = getClosestPart(player.Character)
        
        if part and hitPoint then
            local screenPos, onScreen = Camera:WorldToViewportPoint(hitPoint)
            if not onScreen then continue end
            
            local partPos = Vector2.new(screenPos.X, screenPos.Y)
            local distFromMouse = (mouseLocation - partPos).Magnitude
            
            if distFromMouse <= fovRadius then
                if Config.WallCheck and hasWallBetween(Camera.CFrame.Position, part) then
                    continue
                end
                
                if distFromMouse < bestDist then
                    bestPart = part
                    bestPoint = hitPoint
                    bestDist = distFromMouse
                end
            end
        end
    end
    
    cachedTarget = bestPart
    cachedTargetPoint = bestPoint
end

local function applyPrediction(position, velocity, offset)
    return position
end

local uiUpdateCounter = 0
local UI_UPDATE_RATE = 1

Services.RunService.RenderStepped:Connect(function()
    if not scriptEnabled then return end
    
    mouseLocation = Services.UserInputService:GetMouseLocation()
    
    uiUpdateCounter = uiUpdateCounter + 1
    
    if uiUpdateCounter % UI_UPDATE_RATE == 0 then
        FOVCircle.Position = mouseLocation
        FOVCircle.Radius = Config.FOVSize
        FOVCircle.Visible = Config.ShowFOV
        FOVCircle.Color = Config.AccentColor
        
        if Config.Multipoint then
            MultipointCircle.Position = mouseLocation
            MultipointCircle.Radius = Config.MultipointSize * 3
            MultipointCircle.Visible = Config.ShowFOV
            MultipointCircle.Color = Config.AccentColor
        else
            MultipointCircle.Visible = false
        end
        
        if Config.ShowTargeting and cachedTarget and cachedTargetPoint and Config.Enabled then
            local screenPos, onScreen = Camera:WorldToViewportPoint(cachedTargetPoint)
            
            if onScreen then
                TargetIndicator.Position = Vector2.new(screenPos.X, screenPos.Y)
                TargetIndicator.Visible = true
                TargetIndicator.Color = Color3.fromRGB(52, 199, 89)
                TargetIndicator.Radius = 8
            else
                TargetIndicator.Visible = false
            end
        else
            TargetIndicator.Visible = false
        end
    end
    
    updateESP()
end)

Services.UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Config.Keybind then
        Config.Enabled = not Config.Enabled
    end
    
    if input.KeyCode == currentSpeedKeybind then
        isSpeedEnabled = not isSpeedEnabled
        updateSpeed()
    end
end)

local mt = getrawmetatable(game)
local oldIndex = mt.__index
setreadonly(mt, false)
mt.__index = newcclosure(function(obj, prop)
    if Config.Enabled and scriptEnabled and obj:IsA("Mouse") and (prop == "Hit" or prop == "Target") then
        if cachedTarget and cachedTargetPoint then
            return prop == "Hit" and CFrame.new(cachedTargetPoint) or cachedTarget
        end
    end
    return oldIndex(obj, prop)
end)
setreadonly(mt, true)

Services.RunService.RenderStepped:Connect(function()
    if not Config.Enabled or not scriptEnabled then return end
    updateTarget()
end)

local function setupRapidFire()
    if rapidFireConnection then
        rapidFireConnection:Disconnect()
        rapidFireConnection = nil
    end
    
    if not Config.RapidFire then return end
    
    rapidFireConnection = Services.UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local shooting = true
            
            local connection
            connection = Services.UserInputService.InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    shooting = false
                    connection:Disconnect()
                end
            end)
            
            while shooting and Config.RapidFire and Config.Enabled and scriptEnabled do
                local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if currentTool then
                    currentTool:Activate()
                end
                wait(Config.RapidFireDelay)
            end
        end
    end)
end

setupRapidFire()

local oldRandom
oldRandom = hookfunction(math.random, function(...)
    local args = {...}
    if checkcaller() then return oldRandom(...) end
    if (#args == 0) or (args[1] == -0.05 and args[2] == 0.05) or (args[1] == -0.1) or (args[1] == -0.05) then
        if SpreadMod.BulletSpread.Enabled then
            return oldRandom(...) * (SpreadMod.BulletSpread.Amount / 100)
        end
    end
    return oldRandom(...)
end)

Services.Players.PlayerRemoving:Connect(function(player)
    teamCheckCache[player.UserId] = nil
    knockedCache[player.UserId] = nil
end)

setupWalkSpeed()

-- ════════════════════════════════════════════════════════════════
-- iOS 18 CONTROL CENTER STYLE GUI
-- ════════════════════════════════════════════════════════════════
