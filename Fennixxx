--[[
     ███████╗███████╗███╗   ███╗███╗   ██╗██╗██╗  ██╗██╗  ██╗██╗  ██╗
     ██╔════╝██╔════╝████╗ ████║████╗  ██║██║╚██╗██╔╝╚██╗██╔╝╚██╗██╔╝
     █████╗  █████╗  ██╔████╔██║██╔██╗ ██║██║ ╚███╔╝  ╚███╔╝  ╚███╔╝
     ██╔══╝  ██╔══╝  ██║╚██╔╝██║██║╚██╗██║██║ ██╔██╗  ██╔██╗  ██╔██╗
     ██║     ███████╗██║ ╚═╝ ██║██║ ╚████║██║██╔╝ ██╗██╔╝ ██╗██╔╝ ██╗
     ╚═╝     ╚══════╝╚═╝     ╚═╝╚═╝  ╚═══╝╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝
     
     iOS 18 CONTROL CENTER - RESIZABLE GUI WITH PROPER SHUTDOWN
     Made with ❤ by FENNIXXX Team
     Version 2.0 - Enhanced Edition
]]

-- ════════════════════════════════════════════════════════════════
-- COMPATIBILITY LAYER
-- ════════════════════════════════════════════════════════════════

local request = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
local setclipboard = setclipboard or toclipboard or set_clipboard or (Clipboard and Clipboard.set)
local getrawmetatable = getrawmetatable or debug.getmetatable
local hookfunction = hookfunction or replaceclosure or detour_function
local newcclosure = newcclosure or protect_function or function(f) return f end
local setreadonly = setreadonly or make_writeable or function() end
local checkcaller = checkcaller or is_caller or function() return false end

if not request then
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "FENNIXXX Error";
        Text = "Your executor doesn't support HTTP requests!";
        Duration = 5;
    })
    return
end

if not setclipboard then
    setclipboard = function(text)
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Copy Failed";
            Text = "Clipboard not supported on your executor";
            Duration = 3;
        })
    end
end

-- ════════════════════════════════════════════════════════════════
-- CORE SERVICES
-- ════════════════════════════════════════════════════════════════

local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Workspace = game:GetService("Workspace"),
    CoreGui = game:GetService("CoreGui"),
    HttpService = game:GetService("HttpService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage")
}

local LocalPlayer = Services.Players.LocalPlayer
local Camera = workspace.CurrentCamera

--- KeyAuth Configuration - MULTI-OWNER SUPPORT
local KeyAuthApp = "FENNIXXX"
local KeyAuthOwnerIDs = {
    "Gi9EhXEQsn",
    "B05VCYnbf0",
    "6oOmPZgEug",
    "edcEgR58Gp",
}
local KeyAuthVersion = "1.0"
local KeyAuthURL = "https://keyauth.win/api/1.2/"

local isAuthorized = false
local sessionID = ""
local scriptEnabled = true
local currentOwnerID = nil

-- GLOBAL CLEANUP TABLE
local GlobalCleanup = {
    Connections = {},
    Drawings = {},
    Instances = {},
    Hooks = {}
}

local function addToCleanup(category, item)
    table.insert(GlobalCleanup[category], item)
end

local function performFullCleanup()
    -- Disconnect all connections
    for _, connection in pairs(GlobalCleanup.Connections) do
        pcall(function()
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end)
    end
    
    -- Remove all drawings
    for _, drawing in pairs(GlobalCleanup.Drawings) do
        pcall(function()
            if drawing and drawing.Remove then
                drawing:Remove()
            end
        end)
    end
    
    -- Destroy all instances
    for _, instance in pairs(GlobalCleanup.Instances) do
        pcall(function()
            if instance and instance.Destroy then
                instance:Destroy()
            end
        end)
    end
    
    -- Clear tables
    GlobalCleanup.Connections = {}
    GlobalCleanup.Drawings = {}
    GlobalCleanup.Instances = {}
end

local function getHWID()
    local success, hwid = pcall(function()
        return game:GetService("RbxAnalyticsService"):GetClientId()
    end)
    if success then
        return hwid
    else
        return tostring(game:GetService("HttpService"):GenerateGUID(false))
    end
end

local function initKeyAuth(ownerID)
    local success, response = pcall(function()
        return request({
            Url = KeyAuthURL,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/x-www-form-urlencoded"
            },
            Body = "type=init&ver=" .. KeyAuthVersion .. "&name=" .. KeyAuthApp .. "&ownerid=" .. ownerID
        })
    end)
    
    if not success then
        return false, "Connection failed", nil
    end
    
    if response.StatusCode == 200 then
        local decodeSuccess, data = pcall(function()
            return Services.HttpService:JSONDecode(response.Body)
        end)
        
        if decodeSuccess then
            if data.success then
                return true, "Initialized", data.sessionid
            else
                return false, data.message or "Init failed", nil
            end
        else
            return false, "Invalid response", nil
        end
    else
        return false, "Server error: " .. response.StatusCode, nil
    end
end

local function verifyLicenseParallel(key)
    local hwid = getHWID()
    local results = {}
    local completed = 0
    local totalOwners = #KeyAuthOwnerIDs
    
    for index, ownerID in ipairs(KeyAuthOwnerIDs) do
        spawn(function()
            local initSuccess, initMsg, sid = initKeyAuth(ownerID)
            if initSuccess and sid then
                wait(0.2)
                
                local success, response = pcall(function()
                    return request({
                        Url = KeyAuthURL,
                        Method = "POST",
                        Headers = {
                            ["Content-Type"] = "application/x-www-form-urlencoded"
                        },
                        Body = "type=license&key=" .. Services.HttpService:UrlEncode(key) ..
                               "&sessionid=" .. sid ..
                               "&name=" .. KeyAuthApp ..
                               "&ownerid=" .. ownerID ..
                               "&hwid=" .. hwid
                    })
                end)
                
                if success and response.StatusCode == 200 then
                    local decodeSuccess, data = pcall(function()
                        return Services.HttpService:JSONDecode(response.Body)
                    end)
                    
                    if decodeSuccess and data.success then
                        results[index] = {
                            success = true,
                            ownerID = ownerID,
                            sessionID = sid,
                            data = data
                        }
                    else
                        results[index] = {success = false}
                    end
                else
                    results[index] = {success = false}
                end
            else
                results[index] = {success = false}
            end
            completed = completed + 1
        end)
    end
    
    local startTime = tick()
    while completed < totalOwners and (tick() - startTime) < 10 do
        wait(0.1)
    end
    
    for index, result in pairs(results) do
        if result.success then
            sessionID = result.sessionID
            currentOwnerID = result.ownerID
            
            local exp = "Lifetime"
            if result.data.info and result.data.info.subscriptions then
                for _, sub in pairs(result.data.info.subscriptions) do
                    if sub.expiry and sub.expiry ~= "lifetime" then
                        exp = os.date("%m/%d/%Y %H:%M", tonumber(sub.expiry))
                    end
                end
            end
            return true, "License verified! Expires: " .. exp
        end
    end
    
    return false, "Invalid license key or all owners failed"
end

local function createAuthGUI()
    local authGui = Instance.new("ScreenGui")
    authGui.Name = "KeyAuthGUI"
    authGui.IgnoreGuiInset = true
    authGui.ResetOnSpawn = false
    
    pcall(function()
        authGui.Parent = Services.CoreGui
    end)
    
    if not authGui.Parent then
        authGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    
    addToCleanup("Instances", authGui)
    
    local darkBackground = Instance.new("Frame")
    darkBackground.Size = UDim2.new(1, 0, 1, 0)
    darkBackground.Position = UDim2.new(0, 0, 0, 0)
    darkBackground.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    darkBackground.BorderSizePixel = 0
    darkBackground.BackgroundTransparency = 0.3
    darkBackground.Parent = authGui
    
    local authFrame = Instance.new("Frame")
    authFrame.Size = UDim2.new(0, 380, 0, 460)
    authFrame.Position = UDim2.new(0.5, -190, 0.5, -230)
    authFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    authFrame.BorderSizePixel = 0
    authFrame.BackgroundTransparency = 0.1
    authFrame.Parent = authGui
    
    local authCorner = Instance.new("UICorner", authFrame)
    authCorner.CornerRadius = UDim.new(0, 28)
    
    local authStroke = Instance.new("UIStroke", authFrame)
    authStroke.Color = Color3.fromRGB(200, 200, 200)
    authStroke.Thickness = 1
    authStroke.Transparency = 0.7
    
    local logoText = Instance.new("TextLabel")
    logoText.Size = UDim2.new(1, 0, 0, 70)
    logoText.Position = UDim2.new(0, 0, 0, 30)
    logoText.Text = "FENNIXXX"
    logoText.TextColor3 = Color3.fromRGB(60, 60, 67)
    logoText.TextSize = 34
    logoText.Font = Enum.Font.GothamBold
    logoText.BackgroundTransparency = 1
    logoText.Parent = authFrame
    
    local subtitleLabel = Instance.new("TextLabel")
    subtitleLabel.Size = UDim2.new(1, 0, 0, 25)
    subtitleLabel.Position = UDim2.new(0, 0, 0, 100)
    subtitleLabel.Text = "License Verification"
    subtitleLabel.TextColor3 = Color3.fromRGB(142, 142, 147)
    subtitleLabel.TextSize = 14
    subtitleLabel.Font = Enum.Font.Gotham
    subtitleLabel.BackgroundTransparency = 1
    subtitleLabel.Parent = authFrame
    
    local hwidLabel = Instance.new("TextLabel")
    hwidLabel.Size = UDim2.new(1, -100, 0, 18)
    hwidLabel.Position = UDim2.new(0, 25, 0, 150)
    hwidLabel.Text = "HWID: " .. getHWID()
    hwidLabel.TextColor3 = Color3.fromRGB(142, 142, 147)
    hwidLabel.TextSize = 10
    hwidLabel.Font = Enum.Font.Gotham
    hwidLabel.BackgroundTransparency = 1
    hwidLabel.TextXAlignment = Enum.TextXAlignment.Left
    hwidLabel.TextScaled = false
    hwidLabel.TextWrapped = true
    hwidLabel.Parent = authFrame
    
    local copyHWIDBtn = Instance.new("TextButton")
    copyHWIDBtn.Size = UDim2.new(0, 65, 0, 26)
    copyHWIDBtn.Position = UDim2.new(1, -90, 0, 147)
    copyHWIDBtn.BackgroundColor3 = Color3.fromRGB(0, 122, 255)
    copyHWIDBtn.Text = "Copy"
    copyHWIDBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    copyHWIDBtn.TextSize = 12
    copyHWIDBtn.Font = Enum.Font.GothamMedium
    copyHWIDBtn.BorderSizePixel = 0
    copyHWIDBtn.Parent = authFrame
    
    local copyCorner = Instance.new("UICorner", copyHWIDBtn)
    copyCorner.CornerRadius = UDim.new(0, 8)
    
    local copyConnection = copyHWIDBtn.MouseButton1Click:Connect(function()
        setclipboard(getHWID())
        copyHWIDBtn.Text = "Copied!"
        copyHWIDBtn.BackgroundColor3 = Color3.fromRGB(52, 199, 89)
        wait(1.5)
        copyHWIDBtn.Text = "Copy"
        copyHWIDBtn.BackgroundColor3 = Color3.fromRGB(0, 122, 255)
    end)
    addToCleanup("Connections", copyConnection)
    
    local keyBox = Instance.new("TextBox")
    keyBox.Size = UDim2.new(0, 330, 0, 45)
    keyBox.Position = UDim2.new(0.5, -165, 0, 195)
    keyBox.BackgroundColor3 = Color3.fromRGB(242, 242, 247)
    keyBox.Text = ""
    keyBox.PlaceholderText = "Enter License Key"
    keyBox.PlaceholderColor3 = Color3.fromRGB(174, 174, 178)
    keyBox.TextColor3 = Color3.fromRGB(0, 0, 0)
    keyBox.TextSize = 15
    keyBox.Font = Enum.Font.Gotham
    keyBox.BorderSizePixel = 0
    keyBox.ClearTextOnFocus = false
    keyBox.TextScaled = false
    keyBox.TextWrapped = false
    keyBox.TextXAlignment = Enum.TextXAlignment.Left
    keyBox.ClipsDescendants = true
    keyBox.Parent = authFrame
    
    local keyBoxCorner = Instance.new("UICorner", keyBox)
    keyBoxCorner.CornerRadius = UDim.new(0, 12)
    
    local keyBoxPadding = Instance.new("UIPadding", keyBox)
    keyBoxPadding.PaddingLeft = UDim.new(0, 15)
    keyBoxPadding.PaddingRight = UDim.new(0, 15)
    
    local submitBtn = Instance.new("TextButton")
    submitBtn.Size = UDim2.new(0, 330, 0, 45)
    submitBtn.Position = UDim2.new(0.5, -165, 0, 260)
    submitBtn.BackgroundColor3 = Color3.fromRGB(0, 122, 255)
    submitBtn.Text = "Verify License"
    submitBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    submitBtn.TextSize = 16
    submitBtn.Font = Enum.Font.GothamBold
    submitBtn.BorderSizePixel = 0
    submitBtn.Parent = authFrame
    
    local submitBtnCorner = Instance.new("UICorner", submitBtn)
    submitBtnCorner.CornerRadius = UDim.new(0, 12)
    
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, -40, 0, 30)
    statusLabel.Position = UDim2.new(0, 20, 0, 320)
    statusLabel.Text = ""
    statusLabel.TextColor3 = Color3.fromRGB(255, 59, 48)
    statusLabel.TextSize = 12
    statusLabel.Font = Enum.Font.GothamMedium
    statusLabel.BackgroundTransparency = 1
    statusLabel.TextWrapped = true
    statusLabel.TextScaled = false
    statusLabel.Parent = authFrame
    
    local getKeyBtn = Instance.new("TextButton")
    getKeyBtn.Size = UDim2.new(0, 180, 0, 38)
    getKeyBtn.Position = UDim2.new(0.5, -90, 0, 370)
    getKeyBtn.BackgroundColor3 = Color3.fromRGB(242, 242, 247)
    getKeyBtn.Text = "Get License"
    getKeyBtn.TextColor3 = Color3.fromRGB(0, 122, 255)
    getKeyBtn.TextSize = 14
    getKeyBtn.Font = Enum.Font.GothamMedium
    getKeyBtn.BorderSizePixel = 0
    getKeyBtn.Parent = authFrame
    
    local getKeyCorner = Instance.new("UICorner", getKeyBtn)
    getKeyCorner.CornerRadius = UDim.new(0, 12)
    
    local getKeyConnection = getKeyBtn.MouseButton1Click:Connect(function()
        setclipboard("https://keyauth.win/panel/" .. KeyAuthApp .. "/licenses")
        getKeyBtn.Text = "Link Copied!"
        getKeyBtn.BackgroundColor3 = Color3.fromRGB(52, 199, 89)
        getKeyBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        wait(2)
        getKeyBtn.Text = "Get License"
        getKeyBtn.BackgroundColor3 = Color3.fromRGB(242, 242, 247)
        getKeyBtn.TextColor3 = Color3.fromRGB(0, 122, 255)
    end)
    addToCleanup("Connections", getKeyConnection)
    
    local function verifyKey()
        local key = keyBox.Text
        if key == "" or #key < 10 then
            statusLabel.Text = "Please enter a valid license key"
            statusLabel.TextColor3 = Color3.fromRGB(255, 59, 48)
            
            local originalPos = authFrame.Position
            for i = 1, 3 do
                Services.TweenService:Create(authFrame, TweenInfo.new(0.05), {Position = originalPos + UDim2.new(0, 10, 0, 0)}):Play()
                wait(0.05)
                Services.TweenService:Create(authFrame, TweenInfo.new(0.05), {Position = originalPos - UDim2.new(0, 10, 0, 0)}):Play()
                wait(0.05)
            end
            authFrame.Position = originalPos
            return
        end
        
        submitBtn.Text = "Verifying..."
        submitBtn.BackgroundColor3 = Color3.fromRGB(142, 142, 147)
        statusLabel.TextColor3 = Color3.fromRGB(0, 122, 255)
        statusLabel.Text = "Verifying license..."
        
        local success, message = verifyLicenseParallel(key)
        
        if success then
            isAuthorized = true
            statusLabel.Text = message
            statusLabel.TextColor3 = Color3.fromRGB(52, 199, 89)
            
            submitBtn.Text = "Verified!"
            submitBtn.BackgroundColor3 = Color3.fromRGB(52, 199, 89)
            
            wait(1.5)
            
            Services.TweenService:Create(authFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
                Size = UDim2.new(0, 0, 0, 0),
                Position = UDim2.new(0.5, 0, 0.5, 0)
            }):Play()
            
            Services.TweenService:Create(darkBackground, TweenInfo.new(0.4), {
                BackgroundTransparency = 1
            }):Play()
            
            wait(0.4)
            authGui:Destroy()
            initializeScript()
        else
            submitBtn.Text = "Verify License"
            submitBtn.BackgroundColor3 = Color3.fromRGB(0, 122, 255)
            statusLabel.Text = message
            statusLabel.TextColor3 = Color3.fromRGB(255, 59, 48)
            
            local originalPos = authFrame.Position
            for i = 1, 3 do
                Services.TweenService:Create(authFrame, TweenInfo.new(0.05), {Position = originalPos + UDim2.new(0, 10, 0, 0)}):Play()
                wait(0.05)
                Services.TweenService:Create(authFrame, TweenInfo.new(0.05), {Position = originalPos - UDim2.new(0, 10, 0, 0)}):Play()
                wait(0.05)
            end
            authFrame.Position = originalPos
        end
    end
    
    local submitConnection = submitBtn.MouseButton1Click:Connect(verifyKey)
    addToCleanup("Connections", submitConnection)
    
    local focusConnection = keyBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            verifyKey()
        end
    end)
    addToCleanup("Connections", focusConnection)
    
    authFrame.Size = UDim2.new(0, 0, 0, 0)
    authFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    
    Services.TweenService:Create(authFrame, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.new(0, 380, 0, 460),
        Position = UDim2.new(0.5, -190, 0.5, -230)
    }):Play()
end

local isSpeedEnabled = false
local originalSpeeds = {}
local speedConnection = nil
local currentSpeedKeybind = Enum.KeyCode.T
local currentWalkSpeed = 300

local function saveOriginalSpeed()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local humanoid = LocalPlayer.Character.Humanoid
        if not originalSpeeds[humanoid] then
            originalSpeeds[humanoid] = humanoid.WalkSpeed
        end
    end
end

local function updateSpeed()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local humanoid = LocalPlayer.Character.Humanoid
        
        if isSpeedEnabled then
            humanoid.WalkSpeed = currentWalkSpeed
        else
            if originalSpeeds[humanoid] then
                humanoid.WalkSpeed = originalSpeeds[humanoid]
            end
        end
    end
end

local function setupWalkSpeed()
    if speedConnection then
        speedConnection:Disconnect()
    end
    
    saveOriginalSpeed()
    updateSpeed()
    
    local charAddedConnection = LocalPlayer.CharacterAdded:Connect(function(character)
        character:WaitForChild("Humanoid")
        wait(0.1)
        saveOriginalSpeed()
        updateSpeed()
    end)
    addToCleanup("Connections", charAddedConnection)
    
    speedConnection = Services.RunService.Heartbeat:Connect(function()
        if isSpeedEnabled then
            updateSpeed()
        end
    end)
    addToCleanup("Connections", speedConnection)
end

function initializeScript()
    if not isAuthorized then
        return
    end

local Config = {
    Enabled = true,
    HitPart = "HumanoidRootPart",
    FOVSize = 80,
    TeamCheck = false,
    KnockedCheck = true,
    WallCheck = false,
    VisibleCheck = false,
    MaxDistance = 500,
    Keybind = Enum.KeyCode.C,
    Resolver = false,
    ShowFOV = false,
    RapidFire = false,
    RapidFireDelay = 0.05,
    Multipoint = false,
    MultipointSize = 1,
    ShowTargeting = false,
    
    UpdateRate = 1,
    MaxPlayersToCheck = 15,
    UseSpatialOptimization = true,
    
    GUISize = {Width = 650, Height = 800},
    GUIToggleKey = Enum.KeyCode.Insert,
    
    GUIColor = Color3.fromRGB(245, 245, 250),
    GUITransparency = 0.05,
    AccentColor = Color3.fromRGB(0, 122, 255),
    
    CurrentWeapon = nil,
    CurrentPrediction = Vector3.new(0, 0, 0),
    CurrentMaxDistance = 400,
    
    ESP = {
        Enabled = false,
        ShowBox = false,
        ShowName = false,
        ShowDistance = false,
        ShowHealth = false,
        ShowSkeleton = false,
        BoxColor = Color3.fromRGB(0, 122, 255),
        NameColor = Color3.fromRGB(255, 255, 255),
        DistanceColor = Color3.fromRGB(142, 142, 147),
        HealthBarColor = Color3.fromRGB(52, 199, 89),
        SkeletonColor = Color3.fromRGB(0, 122, 255),
        MaxDistance = 500,
        TeamCheck = false
    }
}

local SpreadMod = {
    BulletSpread = {
        Enabled = true,
        Amount = 70
    }
}

local allBodyParts = {
    "Head",
    "UpperTorso",
    "LowerTorso",
    "HumanoidRootPart",
    "LeftUpperArm",
    "LeftLowerArm",
    "LeftHand",
    "RightUpperArm",
    "RightLowerArm",
    "RightHand",
    "LeftUpperLeg",
    "LeftLowerLeg",
    "LeftFoot",
    "RightUpperLeg",
    "RightLowerLeg",
    "RightFoot"
}

local skeletonConnections = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"}
}

local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 2
FOVCircle.Color = Color3.fromRGB(0, 122, 255)
FOVCircle.Transparency = 1
FOVCircle.NumSides = 24
FOVCircle.Filled = false
addToCleanup("Drawings", FOVCircle)

local TargetIndicator = Drawing.new("Circle")
TargetIndicator.Visible = false
TargetIndicator.Thickness = 3
TargetIndicator.Color = Color3.fromRGB(52, 199, 89)
TargetIndicator.Transparency = 1
TargetIndicator.NumSides = 16
TargetIndicator.Radius = 8
TargetIndicator.Filled = false
addToCleanup("Drawings", TargetIndicator)

local MultipointCircle = Drawing.new("Circle")
MultipointCircle.Visible = false
MultipointCircle.Thickness = 1
MultipointCircle.Color = Color3.fromRGB(0, 122, 255)
MultipointCircle.Transparency = 0.5
MultipointCircle.NumSides = 12
MultipointCircle.Radius = 5
MultipointCircle.Filled = false
addToCleanup("Drawings", MultipointCircle)

local cachedTarget = nil
local cachedTargetPoint = nil
local lastShotTime = 0
local rapidFireConnection = nil

local playerCache = {}
local lastCacheUpdate = 0
local CACHE_UPDATE_INTERVAL = 0.5

local mouseLocation = Vector2.new(0, 0)

local currentWeaponCache = nil
local lastWeaponCheck = 0
local WEAPON_CHECK_INTERVAL = 0.2

local ESPObjects = {}

local function createESP(player)
    if ESPObjects[player] then return end
    
    local esp = {
        Box = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthBar = Drawing.new("Square"),
        HealthBarOutline = Drawing.new("Square"),
        SkeletonLines = {}
    }
    
    for i = 1, #skeletonConnections do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Thickness = 2
        line.Transparency = 1
        table.insert(esp.SkeletonLines, line)
        addToCleanup("Drawings", line)
    end
    
    esp.Box.Visible = false
    esp.Box.Thickness = 2
    esp.Box.Filled = false
    esp.Box.Transparency = 1
    addToCleanup("Drawings", esp.Box)
    
    esp.Name.Visible = false
    esp.Name.Center = true
    esp.Name.Outline = true
    esp.Name.Size = 14
    esp.Name.Font = 2
    addToCleanup("Drawings", esp.Name)
    
    esp.Distance.Visible = false
    esp.Distance.Center = true
    esp.Distance.Outline = true
    esp.Distance.Size = 13
    esp.Distance.Font = 2
    addToCleanup("Drawings", esp.Distance)
    
    esp.HealthBar.Visible = false
    esp.HealthBar.Filled = true
    esp.HealthBar.Thickness = 1
    addToCleanup("Drawings", esp.HealthBar)
    
    esp.HealthBarOutline.Visible = false
    esp.HealthBarOutline.Filled = false
    esp.HealthBarOutline.Thickness = 1
    esp.HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
    addToCleanup("Drawings", esp.HealthBarOutline)
    
    ESPObjects[player] = esp
end

local function removeESP(player)
    if ESPObjects[player] then
        for _, drawing in pairs(ESPObjects[player]) do
            if type(drawing) == "table" then
                for _, line in pairs(drawing) do
                    pcall(function() line:Remove() end)
                end
            else
                pcall(function() drawing:Remove() end)
            end
        end
        ESPObjects[player] = nil
    end
end

local function updateESP()
    if not Config.ESP.Enabled then
        for _, esp in pairs(ESPObjects) do
            for key, drawing in pairs(esp) do
                if key == "SkeletonLines" then
                    for _, line in pairs(drawing) do
                        line.Visible = false
                    end
                else
                    drawing.Visible = false
                end
            end
        end
        return
    end
    
    for player, esp in pairs(ESPObjects) do
        pcall(function()
            if player and player.Character and player ~= LocalPlayer then
                local character = player.Character
                local hrp = character:FindFirstChild("HumanoidRootPart")
                local head = character:FindFirstChild("Head")
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                
                if hrp and head and humanoid and humanoid.Health > 0 then
                    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                    
                    if distance <= Config.ESP.MaxDistance then
                        if Config.ESP.TeamCheck and LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team then
                            for key, drawing in pairs(esp) do
                                if key == "SkeletonLines" then
                                    for _, line in pairs(drawing) do
                                        line.Visible = false
                                    end
                                else
                                    drawing.Visible = false
                                end
                            end
                        else
                            local vector, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                            
                            if onScreen then
                                local headPos = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
                                local legPos = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0))
                                
                                local height = math.abs(headPos.Y - legPos.Y)
                                local width = height / 2
                                
                                if Config.ESP.ShowBox then
                                    esp.Box.Visible = true
                                    esp.Box.Size = Vector2.new(width, height)
                                    esp.Box.Position = Vector2.new(vector.X - width / 2, headPos.Y)
                                    esp.Box.Color = Config.ESP.BoxColor
                                else
                                    esp.Box.Visible = false
                                end
                                
                                if Config.ESP.ShowName then
                                    esp.Name.Visible = true
                                    esp.Name.Text = player.Name
                                    esp.Name.Position = Vector2.new(vector.X, headPos.Y - 20)
                                    esp.Name.Color = Config.ESP.NameColor
                                else
                                    esp.Name.Visible = false
                                end
                                
                                if Config.ESP.ShowDistance then
                                    esp.Distance.Visible = true
                                    esp.Distance.Text = math.floor(distance) .. "m"
                                    esp.Distance.Position = Vector2.new(vector.X, legPos.Y + 5)
                                    esp.Distance.Color = Config.ESP.DistanceColor
                                else
                                    esp.Distance.Visible = false
                                end
                                
                                if Config.ESP.ShowHealth then
                                    local healthPercent = humanoid.Health / humanoid.MaxHealth
                                    
                                    esp.HealthBarOutline.Visible = true
                                    esp.HealthBarOutline.Size = Vector2.new(4, height + 2)
                                    esp.HealthBarOutline.Position = Vector2.new(vector.X - width / 2 - 8, headPos.Y - 1)
                                    
                                    esp.HealthBar.Visible = true
                                    esp.HealthBar.Size = Vector2.new(2, height * healthPercent)
                                    esp.HealthBar.Position = Vector2.new(vector.X - width / 2 - 7, headPos.Y + height - height * healthPercent)
                                    esp.HealthBar.Color = Color3.fromRGB(
                                        math.clamp(255 * (1 - healthPercent), 0, 255),
                                        math.clamp(255 * healthPercent, 0, 255),
                                        0
                                    )
                                else
                                    esp.HealthBar.Visible = false
                                    esp.HealthBarOutline.Visible = false
                                end
                                
                                if Config.ESP.ShowSkeleton then
                                    for i, connection in ipairs(skeletonConnections) do
                                        local part1 = character:FindFirstChild(connection[1])
                                        local part2 = character:FindFirstChild(connection[2])
                                        
                                        if part1 and part2 and esp.SkeletonLines[i] then
                                            local pos1, vis1 = Camera:WorldToViewportPoint(part1.Position)
                                            local pos2, vis2 = Camera:WorldToViewportPoint(part2.Position)
                                            
                                            if vis1 and vis2 then
                                                esp.SkeletonLines[i].Visible = true
                                                esp.SkeletonLines[i].From = Vector2.new(pos1.X, pos1.Y)
                                                esp.SkeletonLines[i].To = Vector2.new(pos2.X, pos2.Y)
                                                esp.SkeletonLines[i].Color = Config.ESP.SkeletonColor
                                            else
                                                esp.SkeletonLines[i].Visible = false
                                            end
                                        elseif esp.SkeletonLines[i] then
                                            esp.SkeletonLines[i].Visible = false
                                        end
                                    end
                                else
                                    for _, line in pairs(esp.SkeletonLines) do
                                        line.Visible = false
                                    end
                                end
                            else
                                for key, drawing in pairs(esp) do
                                    if key == "SkeletonLines" then
                                        for _, line in pairs(drawing) do
                                            line.Visible = false
                                        end
                                    else
                                        drawing.Visible = false
                                    end
                                end
                            end
                        end
                    else
                        for key, drawing in pairs(esp) do
                            if key == "SkeletonLines" then
                                for _, line in pairs(drawing) do
                                    line.Visible = false
                                end
                            else
                                drawing.Visible = false
                            end
                        end
                    end
                else
                    for key, drawing in pairs(esp) do
                        if key == "SkeletonLines" then
                            for _, line in pairs(drawing) do
                                line.Visible = false
                            end
                        else
                            drawing.Visible = false
                        end
                    end
                end
            else
                for key, drawing in pairs(esp) do
                    if key == "SkeletonLines" then
                        for _, line in pairs(drawing) do
                            line.Visible = false
                        end
                    else
                        drawing.Visible = false
                    end
                end
            end
        end)
    end
end

local playerAddedConnection = Services.Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)
addToCleanup("Connections", playerAddedConnection)

local playerRemovingConnection = Services.Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)
addToCleanup("Connections", playerRemovingConnection)

for _, player in ipairs(Services.Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createESP(player)
    end
end

local function getCurrentWeapon()
    local now = tick()
    if now - lastWeaponCheck < WEAPON_CHECK_INTERVAL and currentWeaponCache then
        return currentWeaponCache
    end
    
    lastWeaponCheck = now
    local character = LocalPlayer.Character
    if not character then
        currentWeaponCache = nil
        return nil
    end
    
    local tool = character:FindFirstChildOfClass("Tool")
    currentWeaponCache = tool and tool.Name or nil
    return currentWeaponCache
end

local teamCheckCache = {}
local function isOnSameTeam(player)
    if not Config.TeamCheck then return false end
    if not LocalPlayer.Team or not player.Team then return false end
    
    local cacheKey = player.UserId
    local now = tick()
    
    if teamCheckCache[cacheKey] and now - teamCheckCache[cacheKey].time < 2 then
        return teamCheckCache[cacheKey].result
    end
    
    local result = LocalPlayer.Team == player.Team
    teamCheckCache[cacheKey] = {result = result, time = now}
    return result
end

local knockedCache = {}
local function isKnocked(player)
    if not Config.KnockedCheck then return false end
    
    local cacheKey = player.UserId
    local now = tick()
    
    if knockedCache[cacheKey] and now - knockedCache[cacheKey].time < 0.3 then
        return knockedCache[cacheKey].result
    end
    
    local character = player.Character
    if not character then 
        knockedCache[cacheKey] = {result = false, time = now}
        return false 
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    
    if humanoid and humanoid.Health <= 0 then
        knockedCache[cacheKey] = {result = true, time = now}
        return true
    end
    
    local bodyEffects = character:FindFirstChild("BodyEffects")
    if bodyEffects then
        local koValue = bodyEffects:FindFirstChild("K.O")
        if koValue and koValue.Value == true then
            knockedCache[cacheKey] = {result = true, time = now}
            return true
        end
    end
    
    local ragdoll = character:FindFirstChild("Ragdoll")
    if ragdoll and ragdoll.Value == true then
        knockedCache[cacheKey] = {result = true, time = now}
        return true
    end
    
    if humanoid then
        local state = humanoid:GetState()
        if state == Enum.HumanoidStateType.Dead or
           state == Enum.HumanoidStateType.Physics or
           state == Enum.HumanoidStateType.PlatformStanding then
            knockedCache[cacheKey] = {result = true, time = now}
            return true
        end
    end
    
    knockedCache[cacheKey] = {result = false, time = now}
    return false
end

local wallCheckCache = {}
local function hasWallBetween(origin, targetPart)
    if not Config.WallCheck then return false end
    
    local cacheKey = tostring(targetPart)
    local now = tick()
    
    if wallCheckCache[cacheKey] and now - wallCheckCache[cacheKey].time < 0.2 then
        return wallCheckCache[cacheKey].result
    end
    
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.IgnoreWater = true
    
    local direction = (targetPart.Position - origin)
    local rayResult = workspace:Raycast(origin, direction, rayParams)
    
    local result = false
    if rayResult and rayResult.Instance then
        if not rayResult.Instance:IsDescendantOf(targetPart.Parent) then
            result = true
        end
    end
    
    wallCheckCache[cacheKey] = {result = result, time = now}
    return result
end

local function isVisible(part)
    if not Config.VisibleCheck then return true end
    
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    
    return not hasWallBetween(Camera.CFrame.Position, part)
end

local function resolveVelocity(part)
    return Vector3.new(0, 0, 0)
end

local function getClosestPointOnPart(part, mousePos)
    if not Config.Multipoint then
        return part.Position
    end
    
    local size = part.Size
    local cf = part.CFrame
    
    local multipointSize = Config.MultipointSize / 10
    
    local points = {
        part.Position,
        (cf * CFrame.new(size.X * multipointSize, 0, 0)).Position,
        (cf * CFrame.new(-size.X * multipointSize, 0, 0)).Position,
        (cf * CFrame.new(0, size.Y * multipointSize, 0)).Position,
        (cf * CFrame.new(0, -size.Y * multipointSize, 0)).Position,
    }
    
    local closestPoint = part.Position
    local closestDist = math.huge
    
    for _, point in ipairs(points) do
        local screenPos, onScreen = Camera:WorldToViewportPoint(point)
        if onScreen then
            local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestPoint = point
            end
        end
    end
    
    return closestPoint
end

local function getClosestPart(character)
    if not character then return nil, nil end
    
    if Config.HitPart ~= "Closest Point" then
        local part = character:FindFirstChild(Config.HitPart)
        if part and part:IsA("BasePart") then
            local hitPoint = getClosestPointOnPart(part, mouseLocation)
            return part, hitPoint
        end
    end
    
    local bestPart, bestPoint, bestDist = nil, nil, math.huge
    
    for _, partName in ipairs(allBodyParts) do
        local part = character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            local hitPoint = getClosestPointOnPart(part, mouseLocation)
            local screenPos, onScreen = Camera:WorldToViewportPoint(hitPoint)
            
            if onScreen then
                local partPos = Vector2.new(screenPos.X, screenPos.Y)
                local dist = (mouseLocation - partPos).Magnitude
                
                if dist < bestDist then
                    bestPart = part
                    bestPoint = hitPoint
                    bestDist = dist
                end
            end
        end
    end
    
    return bestPart, bestPoint
end

local function updatePlayerCache()
    local now = tick()
    if now - lastCacheUpdate < CACHE_UPDATE_INTERVAL then return end
    lastCacheUpdate = now
    
    playerCache = {}
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myPos then return end
    
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (myPos.Position - player.Character.HumanoidRootPart.Position).Magnitude
            
            if distance <= Config.CurrentMaxDistance * 1.3 then
                table.insert(playerCache, {
                    player = player,
                    distance = distance
                })
            end
        end
    end
    
    table.sort(playerCache, function(a, b) return a.distance < b.distance end)
end

local lastTargetUpdate = 0
local TARGET_UPDATE_INTERVAL = 0.016

local function updateTarget()
    local now = tick()
    if now - lastTargetUpdate < TARGET_UPDATE_INTERVAL then return end
    lastTargetUpdate = now
    
    updatePlayerCache()
    
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        cachedTarget = nil
        cachedTargetPoint = nil
        return
    end
    
    local fovRadius = Config.FOVSize
    local bestPart, bestPoint, bestDist = nil, nil, math.huge
    
    local playersToCheck = math.min(#playerCache, Config.MaxPlayersToCheck)
    
    for i = 1, playersToCheck do
        local data = playerCache[i]
        local player = data.player
        
        if Config.TeamCheck and isOnSameTeam(player) then continue end
        if Config.KnockedCheck and isKnocked(player) then continue end
        
        local part, hitPoint = getClosestPart(player.Character)
        
        if part and hitPoint then
            local screenPos, onScreen = Camera:WorldToViewportPoint(hitPoint)
            if not onScreen then continue end
            
            local partPos = Vector2.new(screenPos.X, screenPos.Y)
            local distFromMouse = (mouseLocation - partPos).Magnitude
            
            if distFromMouse <= fovRadius then
                if Config.WallCheck and hasWallBetween(Camera.CFrame.Position, part) then
                    continue
                end
                
                if distFromMouse < bestDist then
                    bestPart = part
                    bestPoint = hitPoint
                    bestDist = distFromMouse
                end
            end
        end
    end
    
    cachedTarget = bestPart
    cachedTargetPoint = bestPoint
end

local function applyPrediction(position, velocity, offset)
    return position
end

local uiUpdateCounter = 0
local UI_UPDATE_RATE = 1

local renderSteppedConnection = Services.RunService.RenderStepped:Connect(function()
    if not scriptEnabled then return end
    
    mouseLocation = Services.UserInputService:GetMouseLocation()
    
    uiUpdateCounter = uiUpdateCounter + 1
    
    if uiUpdateCounter % UI_UPDATE_RATE == 0 then
        FOVCircle.Position = mouseLocation
        FOVCircle.Radius = Config.FOVSize
        FOVCircle.Visible = Config.ShowFOV
        FOVCircle.Color = Config.AccentColor
        
        if Config.Multipoint then
            MultipointCircle.Position = mouseLocation
            MultipointCircle.Radius = Config.MultipointSize * 3
            MultipointCircle.Visible = Config.ShowFOV
            MultipointCircle.Color = Config.AccentColor
        else
            MultipointCircle.Visible = false
        end
        
        if Config.ShowTargeting and cachedTarget and cachedTargetPoint and Config.Enabled then
            local screenPos, onScreen = Camera:WorldToViewportPoint(cachedTargetPoint)
            
            if onScreen then
                TargetIndicator.Position = Vector2.new(screenPos.X, screenPos.Y)
                TargetIndicator.Visible = true
                TargetIndicator.Color = Color3.fromRGB(52, 199, 89)
                TargetIndicator.Radius = 8
            else
                TargetIndicator.Visible = false
            end
        else
            TargetIndicator.Visible = false
        end
    end
    
    updateESP()
end)
addToCleanup("Connections", renderSteppedConnection)

local inputBeganConnection = Services.UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Config.Keybind then
        Config.Enabled = not Config.Enabled
    end
    
    if input.KeyCode == currentSpeedKeybind then
        isSpeedEnabled = not isSpeedEnabled
        updateSpeed()
    end
end)
addToCleanup("Connections", inputBeganConnection)

pcall(function()
    if not getrawmetatable or not hookfunction then return end
    
    local mt = getrawmetatable(game)
    local oldIndex = mt.__index
    setreadonly(mt, false)
    
    mt.__index = newcclosure(function(obj, prop)
        if Config.Enabled and scriptEnabled and obj:IsA("Mouse") and (prop == "Hit" or prop == "Target") then
            if cachedTarget and cachedTargetPoint then
                return prop == "Hit" and CFrame.new(cachedTargetPoint) or cachedTarget
            end
        end
        return oldIndex(obj, prop)
    end)
    
    setreadonly(mt, true)
end)

local targetUpdateConnection = Services.RunService.RenderStepped:Connect(function()
    if not Config.Enabled or not scriptEnabled then return end
    updateTarget()
end)
addToCleanup("Connections", targetUpdateConnection)

local function setupRapidFire()
    if rapidFireConnection then
        rapidFireConnection:Disconnect()
        rapidFireConnection = nil
    end
    
    if not Config.RapidFire then return end
    
    rapidFireConnection = Services.UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local shooting = true
            
            local connection
            connection = Services.UserInputService.InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    shooting = false
                    connection:Disconnect()
                end
            end)
            
            while shooting and Config.RapidFire and Config.Enabled and scriptEnabled do
                local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if currentTool then
                    currentTool:Activate()
                end
                wait(Config.RapidFireDelay)
            end
        end
    end)
    addToCleanup("Connections", rapidFireConnection)
end

setupRapidFire()

pcall(function()
    if not hookfunction then return end
    
    local oldRandom
    oldRandom = hookfunction(math.random, function(...)
        local args = {...}
        if checkcaller() then return oldRandom(...) end
        if (#args == 0) or (args[1] == -0.05 and args[2] == 0.05) or (args[1] == -0.1) or (args[1] == -0.05) then
            if SpreadMod.BulletSpread.Enabled then
                return oldRandom(...) * (SpreadMod.BulletSpread.Amount / 100)
            end
        end
        return oldRandom(...)
    end)
end)

local playerRemovingConnection2 = Services.Players.PlayerRemoving:Connect(function(player)
    teamCheckCache[player.UserId] = nil
    knockedCache[player.UserId] = nil
end)
addToCleanup("Connections", playerRemovingConnection2)

setupWalkSpeed()

-- ════════════════════════════════════════════════════════════════
-- iOS 18 RESIZABLE GUI WITH PROPER SHUTDOWN
-- ════════════════════════════════════════════════════════════════

local gui = Instance.new("ScreenGui")
gui.IgnoreGuiInset = true
gui.ResetOnSpawn = false
gui.Name = "FennixAimUI"

pcall(function()
    gui.Parent = Services.CoreGui
end)

if not gui.Parent then
    gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
end

addToCleanup("Instances", gui)

local blurEffect = Instance.new("BlurEffect")
blurEffect.Size = 0
blurEffect.Parent = game:GetService("Lighting")
addToCleanup("Instances", blurEffect)

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, Config.GUISize.Width, 0, Config.GUISize.Height)
mainFrame.Position = UDim2.new(0.5, -Config.GUISize.Width/2, 0.5, -Config.GUISize.Height/2)
mainFrame.BackgroundColor3 = Config.GUIColor
mainFrame.BorderSizePixel = 0
mainFrame.BackgroundTransparency = Config.GUITransparency
mainFrame.Active = true
mainFrame.ClipsDescendants = false
mainFrame.Visible = false
mainFrame.Parent = gui

local mainCorner = Instance.new("UICorner", mainFrame)
mainCorner.CornerRadius = UDim.new(0, 28)

local mainStroke = Instance.new("UIStroke", mainFrame)
mainStroke.Color = Color3.fromRGB(210, 210, 215)
mainStroke.Thickness = 3
mainStroke.Transparency = 0.3

-- RAINBOW BORDER ANIMATION
local rainbowColors = {
    Color3.fromRGB(255, 0, 0),
    Color3.fromRGB(255, 127, 0),
    Color3.fromRGB(255, 255, 0),
    Color3.fromRGB(0, 255, 0),
    Color3.fromRGB(0, 127, 255),
    Color3.fromRGB(0, 0, 255),
    Color3.fromRGB(139, 0, 255),
    Color3.fromRGB(255, 0, 255),
}

local currentColorIndex = 1
local colorTransitionTime = 0

spawn(function()
    while wait() and scriptEnabled do
        if mainFrame.Parent then
            colorTransitionTime = colorTransitionTime + 0.02
            
            if colorTransitionTime >= 1 then
                colorTransitionTime = 0
                currentColorIndex = currentColorIndex % #rainbowColors + 1
            end
            
            local nextColorIndex = currentColorIndex % #rainbowColors + 1
            local currentColor = rainbowColors[currentColorIndex]
            local nextColor = rainbowColors[nextColorIndex]
            
            mainStroke.Color = currentColor:Lerp(nextColor, colorTransitionTime)
        end
    end
end)

-- RESIZABLE EDGES
local resizeHandles = {}
local resizing = false
local resizeDirection = ""
local resizeStart = Vector2.new(0, 0)
local originalSize = mainFrame.Size
local originalPosition = mainFrame.Position
local minSize = Vector2.new(400, 500)
local maxSize = Vector2.new(1200, 1000)

local handlePositions = {
    {name = "Right", size = UDim2.new(0, 8, 1, -60), position = UDim2.new(1, -4, 0, 30), cursor = "rbxasset://SystemCursors/SizeEW"},
    {name = "Left", size = UDim2.new(0, 8, 1, -60), position = UDim2.new(0, -4, 0, 30), cursor = "rbxasset://SystemCursors/SizeEW"},
    {name = "Bottom", size = UDim2.new(1, -60, 0, 8), position = UDim2.new(0, 30, 1, -4), cursor = "rbxasset://SystemCursors/SizeNS"},
    {name = "Top", size = UDim2.new(1, -60, 0, 8), position = UDim2.new(0, 30, 0, -4), cursor = "rbxasset://SystemCursors/SizeNS"},
    {name = "BottomRight", size = UDim2.new(0, 16, 0, 16), position = UDim2.new(1, -8, 1, -8), cursor = "rbxasset://SystemCursors/SizeNWSE"},
    {name = "BottomLeft", size = UDim2.new(0, 16, 0, 16), position = UDim2.new(0, -8, 1, -8), cursor = "rbxasset://SystemCursors/SizeNESW"},
    {name = "TopRight", size = UDim2.new(0, 16, 0, 16), position = UDim2.new(1, -8, 0, -8), cursor = "rbxasset://SystemCursors/SizeNESW"},
    {name = "TopLeft", size = UDim2.new(0, 16, 0, 16), position = UDim2.new(0, -8, 0, -8), cursor = "rbxasset://SystemCursors/SizeNWSE"},
}

for _, handleData in ipairs(handlePositions) do
    local handle = Instance.new("TextButton")
    handle.Name = handleData.name .. "Handle"
    handle.Size = handleData.size
    handle.Position = handleData.position
    handle.BackgroundTransparency = 1
    handle.Text = ""
    handle.ZIndex = 150
    handle.Parent = mainFrame
    
    local handleConnection1 = handle.MouseEnter:Connect(function()
        Services.UserInputService.MouseIcon = handleData.cursor
    end)
    addToCleanup("Connections", handleConnection1)
    
    local handleConnection2 = handle.MouseLeave:Connect(function()
        if not resizing then
            Services.UserInputService.MouseIcon = ""
        end
    end)
    addToCleanup("Connections", handleConnection2)
    
    local handleConnection3 = handle.MouseButton1Down:Connect(function()
        resizing = true
        resizeDirection = handleData.name
        resizeStart = Services.UserInputService:GetMouseLocation()
        originalSize = mainFrame.Size
        originalPosition = mainFrame.Position
    end)
    addToCleanup("Connections", handleConnection3)
    
    resizeHandles[handleData.name] = handle
end

local resizeConnection = Services.UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        resizing = false
        resizeDirection = ""
        Services.UserInputService.MouseIcon = ""
    end
end)
addToCleanup("Connections", resizeConnection)

local resizeUpdateConnection = Services.RunService.RenderStepped:Connect(function()
    if resizing and resizeDirection ~= "" then
        local currentMouse = Services.UserInputService:GetMouseLocation()
        local delta = currentMouse - resizeStart
        
        local newWidth = originalSize.X.Offset
        local newHeight = originalSize.Y.Offset
        local newX = originalPosition.X.Offset
        local newY = originalPosition.Y.Offset
        
        if resizeDirection:find("Right") then
            newWidth = math.clamp(originalSize.X.Offset + delta.X, minSize.X, maxSize.X)
        end
        
        if resizeDirection:find("Left") then
            local proposedWidth = originalSize.X.Offset - delta.X
            if proposedWidth >= minSize.X and proposedWidth <= maxSize.X then
                newWidth = proposedWidth
                newX = originalPosition.X.Offset + delta.X
            end
        end
        
        if resizeDirection:find("Bottom") then
            newHeight = math.clamp(originalSize.Y.Offset + delta.Y, minSize.Y, maxSize.Y)
        end
        
        if resizeDirection:find("Top") then
            local proposedHeight = originalSize.Y.Offset - delta.Y
            if proposedHeight >= minSize.Y and proposedHeight <= maxSize.Y then
                newHeight = proposedHeight
                newY = originalPosition.Y.Offset + delta.Y
            end
        end
        
        mainFrame.Size = UDim2.new(0, newWidth, 0, newHeight)
        mainFrame.Position = UDim2.new(originalPosition.X.Scale, newX, originalPosition.Y.Scale, newY)
        
        Config.GUISize.Width = newWidth
        Config.GUISize.Height = newHeight
        
        if scrollFrame then
            scrollFrame.Size = UDim2.new(1, -24, 1, -90)
        end
    end
end)
addToCleanup("Connections", resizeUpdateConnection)

-- DRAG FUNCTIONALITY
local dragging = false
local dragStart = Vector2.new(0, 0)
local startPos = UDim2.new(0, 0, 0, 0)

local dragButton = Instance.new("TextButton")
dragButton.Size = UDim2.new(1, -120, 0, 60)
dragButton.Position = UDim2.new(0, 0, 0, 0)
dragButton.BackgroundTransparency = 1
dragButton.Text = ""
dragButton.ZIndex = 10
dragButton.Parent = mainFrame

local dragConnection1 = dragButton.MouseButton1Down:Connect(function()
    dragging = true
    dragStart = Services.UserInputService:GetMouseLocation()
    startPos = mainFrame.Position
end)
addToCleanup("Connections", dragConnection1)

local dragConnection2 = Services.UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)
addToCleanup("Connections", dragConnection2)

local dragUpdateConnection = Services.RunService.RenderStepped:Connect(function()
    if dragging then
        local currentMouse = Services.UserInputService:GetMouseLocation()
        local delta = currentMouse - dragStart
        
        mainFrame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)
addToCleanup("Connections", dragUpdateConnection)

local closeButtonInside = Instance.new("TextButton")
closeButtonInside.Size = UDim2.new(0, 45, 0, 45)
closeButtonInside.Position = UDim2.new(1, -65, 0, 12)
closeButtonInside.BackgroundColor3 = Color3.fromRGB(230, 230, 235)
closeButtonInside.Text = "✕"
closeButtonInside.TextColor3 = Color3.fromRGB(0, 0, 0)
closeButtonInside.TextSize = 24
closeButtonInside.Font = Enum.Font.GothamBold
closeButtonInside.BorderSizePixel = 0
closeButtonInside.ZIndex = 100
closeButtonInside.Parent = mainFrame

local closeCornerInside = Instance.new("UICorner", closeButtonInside)
closeCornerInside.CornerRadius = UDim.new(1, 0)

local closeStrokeInside = Instance.new("UIStroke", closeButtonInside)
closeStrokeInside.Color = Color3.fromRGB(210, 210, 215)
closeStrokeInside.Thickness = 1
closeStrokeInside.Transparency = 0.5

local closeConnection = closeButtonInside.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
    
    Services.TweenService:Create(blurEffect, TweenInfo.new(0.3), {
        Size = 0
    }):Play()
end)
addToCleanup("Connections", closeConnection)

local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Size = UDim2.new(1, -24, 1, -90)
scrollFrame.Position = UDim2.new(0, 12, 0, 78)
scrollFrame.BackgroundTransparency = 1
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 6
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(142, 142, 147)
scrollFrame.Parent = mainFrame

local scrollLayout = Instance.new("UIListLayout")
scrollLayout.Parent = scrollFrame
scrollLayout.SortOrder = Enum.SortOrder.LayoutOrder
scrollLayout.Padding = UDim.new(0, 12)
scrollLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center

local scrollLayoutConnection = scrollLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, scrollLayout.AbsoluteContentSize.Y + 20)
end)
addToCleanup("Connections", scrollLayoutConnection)

local function updateGUIColors(newColor)
    Config.AccentColor = newColor
    FOVCircle.Color = newColor
    MultipointCircle.Color = newColor
    
    for _, obj in pairs(scrollFrame:GetDescendants()) do
        if obj:IsA("TextLabel") and obj.Name == "ValueLabel" then
            obj.TextColor3 = newColor
        elseif obj:IsA("Frame") and obj.Name == "SliderFill" then
            obj.BackgroundColor3 = newColor
        elseif obj:IsA("TextButton") then
            if obj.Parent and obj.Parent:IsA("Frame") then
                local parentFrame = obj.Parent
                if parentFrame.Name:find("Keybind") then
                    if obj.Text ~= "..." then
                        obj.TextColor3 = newColor
                    end
                end
            end
        end
    end
end

local function createCircleButton(name, order, defaultValue, callback)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(0, 120, 0, 135)
    container.BackgroundTransparency = 1
    container.LayoutOrder = order
    
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 100, 0, 100)
    button.Position = UDim2.new(0.5, -50, 0, 0)
    button.BackgroundColor3 = defaultValue and Color3.fromRGB(52, 199, 89) or Color3.fromRGB(255, 255, 255)
    button.Text = ""
    button.BorderSizePixel = 0
    button.BackgroundTransparency = 0.15
    button.Parent = container
    
    local btnCorner = Instance.new("UICorner", button)
    btnCorner.CornerRadius = UDim.new(1, 0)
    
    local btnStroke = Instance.new("UIStroke", button)
    btnStroke.Color = Color3.fromRGB(210, 210, 215)
    btnStroke.Thickness = 2
    btnStroke.Transparency = defaultValue and 1 or 0.5
    
    local iconLabel = Instance.new("TextLabel")
    iconLabel.Size = UDim2.new(1, 0, 1, 0)
    iconLabel.Position = UDim2.new(0, 0, 0, 0)
    iconLabel.BackgroundTransparency = 1
    iconLabel.Text = name:sub(1, 1):upper()
    iconLabel.TextColor3 = defaultValue and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(100, 100, 105)
    iconLabel.TextSize = 32
    iconLabel.Font = Enum.Font.GothamBold
    iconLabel.TextYAlignment = Enum.TextYAlignment.Center
    iconLabel.Parent = button
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0, 30)
    nameLabel.Position = UDim2.new(0, 0, 0, 105)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = name
    nameLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
    nameLabel.TextSize = 12
    nameLabel.Font = Enum.Font.Gotham
    nameLabel.TextWrapped = true
    nameLabel.TextYAlignment = Enum.TextYAlignment.Top
    nameLabel.Parent = container
    
    local enabled = defaultValue
    
    local btnConnection = button.MouseButton1Click:Connect(function()
        enabled = not enabled
        
        Services.TweenService:Create(button, TweenInfo.new(0.25), {
            BackgroundColor3 = enabled and Color3.fromRGB(52, 199, 89) or Color3.fromRGB(255, 255, 255)
        }):Play()
        
        Services.TweenService:Create(btnStroke, TweenInfo.new(0.25), {
            Transparency = enabled and 1 or 0.5
        }):Play()
        
        Services.TweenService:Create(iconLabel, TweenInfo.new(0.25), {
            TextColor3 = enabled and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(100, 100, 105)
        }):Play()
        
        callback(enabled)
    end)
    addToCleanup("Connections", btnConnection)
    
    return container, button
end

local function createModuleSection(title, order)
    local section = Instance.new("Frame")
    section.Size = UDim2.new(0, scrollFrame.AbsoluteSize.X - 12, 0, 45)
    section.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    section.BorderSizePixel = 0
    section.BackgroundTransparency = 0.3
    section.LayoutOrder = order
    section.Parent = scrollFrame
    
    local sectionCorner = Instance.new("UICorner", section)
    sectionCorner.CornerRadius = UDim.new(0, 16)
    
    local sectionTitle = Instance.new("TextLabel")
    sectionTitle.Size = UDim2.new(1, -20, 1, 0)
    sectionTitle.Position = UDim2.new(0, 16, 0, 0)
    sectionTitle.Text = title
    sectionTitle.TextColor3 = Color3.fromRGB(0, 0, 0)
    sectionTitle.TextSize = 18
    sectionTitle.Font = Enum.Font.GothamBold
    sectionTitle.BackgroundTransparency = 1
    sectionTitle.TextXAlignment = Enum.TextXAlignment.Left
    sectionTitle.TextYAlignment = Enum.TextYAlignment.Center
    sectionTitle.Parent = section
    
    return section
end

local function createModernSlider(name, order, min, max, defaultValue, callback, isDecimal)
    local sliderFrame = Instance.new("Frame")
    sliderFrame.Size = UDim2.new(0, scrollFrame.AbsoluteSize.X - 12, 0, 75)
    sliderFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    sliderFrame.BorderSizePixel = 0
    sliderFrame.BackgroundTransparency = 0.3
    sliderFrame.LayoutOrder = order
    sliderFrame.Parent = scrollFrame
    
    local sliderCorner = Instance.new("UICorner", sliderFrame)
    sliderCorner.CornerRadius = UDim.new(0, 16)
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.5, 0, 0, 26)
    label.Position = UDim2.new(0, 16, 0, 12)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(0, 0, 0)
    label.TextSize = 15
    label.Font = Enum.Font.GothamMedium
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = sliderFrame
    
    local valueLabel = Instance.new("TextLabel")
    valueLabel.Name = "ValueLabel"
    valueLabel.Size = UDim2.new(0.45, 0, 0, 26)
    valueLabel.Position = UDim2.new(0.55, -16, 0, 12)
    valueLabel.Text = isDecimal and string.format("%.2f", defaultValue) or tostring(defaultValue)
    valueLabel.TextColor3 = Config.AccentColor
    valueLabel.TextSize = 15
    valueLabel.Font = Enum.Font.GothamBold
    valueLabel.BackgroundTransparency = 1
    valueLabel.TextXAlignment = Enum.TextXAlignment.Right
    valueLabel.TextYAlignment = Enum.TextYAlignment.Center
    valueLabel.Parent = sliderFrame
    
    local sliderBg = Instance.new("Frame")
    sliderBg.Size = UDim2.new(1, -32, 0, 8)
    sliderBg.Position = UDim2.new(0, 16, 0, 52)
    sliderBg.BackgroundColor3 = Color3.fromRGB(220, 220, 225)
    sliderBg.BorderSizePixel = 0
    sliderBg.Parent = sliderFrame
    
    local sliderBgCorner = Instance.new("UICorner", sliderBg)
    sliderBgCorner.CornerRadius = UDim.new(1, 0)
    
    local sliderFill = Instance.new("Frame")
    sliderFill.Name = "SliderFill"
    sliderFill.Size = UDim2.new((defaultValue - min) / (max - min), 0, 1, 0)
    sliderFill.BackgroundColor3 = Config.AccentColor
    sliderFill.BorderSizePixel = 0
    sliderFill.Parent = sliderBg
    
    local sliderFillCorner = Instance.new("UICorner", sliderFill)
    sliderFillCorner.CornerRadius = UDim.new(1, 0)
    
    local dragging = false
    local sliderConnection1 = sliderBg.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
        end
    end)
    addToCleanup("Connections", sliderConnection1)
    
    local sliderConnection2 = Services.UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    addToCleanup("Connections", sliderConnection2)
    
    local sliderConnection3 = Services.RunService.RenderStepped:Connect(function()
        if dragging then
            local mousePos = Services.UserInputService:GetMouseLocation()
            local relX = math.clamp((mousePos.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
            
            Services.TweenService:Create(sliderFill, TweenInfo.new(0.1), {
                Size = UDim2.new(relX, 0, 1, 0)
            }):Play()
            
            local value = min + (max - min) * relX
            if not isDecimal then
                value = math.floor(value)
            end
            
            valueLabel.Text = isDecimal and string.format("%.2f", value) or tostring(value)
            callback(value)
        end
    end)
    addToCleanup("Connections", sliderConnection3)
    
    return sliderFrame
end

local function createCompactToggle(name, order, defaultValue, callback)
    local toggleFrame = Instance.new("Frame")
    toggleFrame.Size = UDim2.new(0, scrollFrame.AbsoluteSize.X - 12, 0, 52)
    toggleFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    toggleFrame.BorderSizePixel = 0
    toggleFrame.BackgroundTransparency = 0.3
    toggleFrame.LayoutOrder = order
    toggleFrame.Parent = scrollFrame
    
    local toggleCorner = Instance.new("UICorner", toggleFrame)
    toggleCorner.CornerRadius = UDim.new(0, 16)
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.65, 0, 1, 0)
    label.Position = UDim2.new(0, 16, 0, 0)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(0, 0, 0)
    label.TextSize = 15
    label.Font = Enum.Font.Gotham
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = toggleFrame
    
    local toggle = Instance.new("TextButton")
    toggle.Size = UDim2.new(0, 51, 0, 31)
    toggle.Position = UDim2.new(1, -67, 0.5, -15.5)
    toggle.BackgroundColor3 = defaultValue and Color3.fromRGB(52, 199, 89) or Color3.fromRGB(220, 220, 225)
    toggle.Text = ""
    toggle.BorderSizePixel = 0
    toggle.Parent = toggleFrame
    
    local toggleCorner2 = Instance.new("UICorner", toggle)
    toggleCorner2.CornerRadius = UDim.new(1, 0)
    
    local circle = Instance.new("Frame")
    circle.Size = UDim2.new(0, 27, 0, 27)
    circle.Position = defaultValue and UDim2.new(0, 22, 0, 2) or UDim2.new(0, 2, 0, 2)
    circle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    circle.BorderSizePixel = 0
    circle.Parent = toggle
    
    local circleCorner = Instance.new("UICorner", circle)
    circleCorner.CornerRadius = UDim.new(1, 0)
    
    local enabled = defaultValue
    
    local toggleConnection = toggle.MouseButton1Click:Connect(function()
        enabled = not enabled
        
        Services.TweenService:Create(toggle, TweenInfo.new(0.25), {
            BackgroundColor3 = enabled and Color3.fromRGB(52, 199, 89) or Color3.fromRGB(220, 220, 225)
        }):Play()
        
        Services.TweenService:Create(circle, TweenInfo.new(0.25), {
            Position = enabled and UDim2.new(0, 22, 0, 2) or UDim2.new(0, 2, 0, 2)
        }):Play()
        
        callback(enabled)
    end)
    addToCleanup("Connections", toggleConnection)
    
    return toggleFrame
end

local function createDropdown(name, order, options, defaultValue, callback)
    local dropdownFrame = Instance.new("Frame")
    dropdownFrame.Size = UDim2.new(0, scrollFrame.AbsoluteSize.X - 12, 0, 52)
    dropdownFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    dropdownFrame.BorderSizePixel = 0
    dropdownFrame.BackgroundTransparency = 0.3
    dropdownFrame.LayoutOrder = order
    dropdownFrame.ClipsDescendants = false
    dropdownFrame.Parent = scrollFrame
    
    local dropdownCorner = Instance.new("UICorner", dropdownFrame)
    dropdownCorner.CornerRadius = UDim.new(0, 16)
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.35, 0, 1, 0)
    label.Position = UDim2.new(0, 16, 0, 0)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(0, 0, 0)
    label.TextSize = 15
    label.Font = Enum.Font.Gotham
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = dropdownFrame
    
    local selectedBtn = Instance.new("TextButton")
    selectedBtn.Size = UDim2.new(0.6, -16, 0, 36)
    selectedBtn.Position = UDim2.new(0.4, 0, 0.5, -18)
    selectedBtn.BackgroundColor3 = Color3.fromRGB(242, 242, 247)
    selectedBtn.Text = defaultValue
    selectedBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
    selectedBtn.TextSize = 14
    selectedBtn.Font = Enum.Font.GothamMedium
    selectedBtn.BorderSizePixel = 0
    selectedBtn.Parent = dropdownFrame
    
    local selectedCorner = Instance.new("UICorner", selectedBtn)
    selectedCorner.CornerRadius = UDim.new(0, 10)
    
    local optionsFrame = Instance.new("Frame")
    optionsFrame.Size = UDim2.new(0.6, -16, 0, 0)
    optionsFrame.Position = UDim2.new(0.4, 0, 1, 4)
    optionsFrame.BackgroundColor3 = Color3.fromRGB(242, 242, 247)
    optionsFrame.BackgroundTransparency = 0
    optionsFrame.BorderSizePixel = 0
    optionsFrame.Visible = false
    optionsFrame.ClipsDescendants = true
    optionsFrame.ZIndex = 100
    optionsFrame.Parent = dropdownFrame
    
    local optionsCorner = Instance.new("UICorner", optionsFrame)
    optionsCorner.CornerRadius = UDim.new(0, 12)
    
    local optionsShadow = Instance.new("UIStroke", optionsFrame)
    optionsShadow.Color = Color3.fromRGB(0, 0, 0)
    optionsShadow.Thickness = 2
    optionsShadow.Transparency = 0.8
    
    local optionsLayout = Instance.new("UIListLayout", optionsFrame)
    optionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    optionsLayout.Padding = UDim.new(0, 2)
    optionsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    optionsLayout.VerticalAlignment = Enum.VerticalAlignment.Top
    
    local optionsPadding = Instance.new("UIPadding", optionsFrame)
    optionsPadding.PaddingTop = UDim.new(0, 4)
    optionsPadding.PaddingBottom = UDim.new(0, 4)
    optionsPadding.PaddingLeft = UDim.new(0, 4)
    optionsPadding.PaddingRight = UDim.new(0, 4)
    
    local isOpen = false
    
    local selectedBtnConnection = selectedBtn.MouseButton1Click:Connect(function()
        isOpen = not isOpen
        
        if isOpen then
            optionsFrame.Visible = true
            Services.TweenService:Create(optionsFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.new(0.6, -16, 0, math.min(#options * 40 + 8, 240))
            }):Play()
        else
            Services.TweenService:Create(optionsFrame, TweenInfo.new(0.2), {
                Size = UDim2.new(0.6, -16, 0, 0)
            }):Play()
            wait(0.2)
            optionsFrame.Visible = false
        end
    end)
    addToCleanup("Connections", selectedBtnConnection)
    
    for i, option in ipairs(options) do
        local optionBtn = Instance.new("TextButton")
        optionBtn.Size = UDim2.new(1, -8, 0, 36)
        optionBtn.Position = UDim2.new(0, 0, 0, 0)
        optionBtn.BackgroundColor3 = option == defaultValue and Config.AccentColor or Color3.fromRGB(255, 255, 255)
        optionBtn.BackgroundTransparency = 0
        optionBtn.Text = option
        optionBtn.TextColor3 = option == defaultValue and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(0, 0, 0)
        optionBtn.TextSize = 13
        optionBtn.Font = Enum.Font.GothamMedium
        optionBtn.BorderSizePixel = 0
        optionBtn.LayoutOrder = i
        optionBtn.ZIndex = 101
        optionBtn.Parent = optionsFrame
        
        local optionCorner = Instance.new("UICorner", optionBtn)
        optionCorner.CornerRadius = UDim.new(0, 8)
        
        local optionEnterConnection = optionBtn.MouseEnter:Connect(function()
            if optionBtn.BackgroundColor3 ~= Config.AccentColor then
                Services.TweenService:Create(optionBtn, TweenInfo.new(0.15), {
                    BackgroundColor3 = Color3.fromRGB(230, 230, 235)
                }):Play()
            end
        end)
        addToCleanup("Connections", optionEnterConnection)
        
        local optionLeaveConnection = optionBtn.MouseLeave:Connect(function()
            if optionBtn.BackgroundColor3 ~= Config.AccentColor then
                Services.TweenService:Create(optionBtn, TweenInfo.new(0.15), {
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                }):Play()
            end
        end)
        addToCleanup("Connections", optionLeaveConnection)
        
        local optionClickConnection = optionBtn.MouseButton1Click:Connect(function()
            selectedBtn.Text = option
            callback(option)
            
            for _, btn in pairs(optionsFrame:GetChildren()) do
                if btn:IsA("TextButton") then
                    Services.TweenService:Create(btn, TweenInfo.new(0.2), {
                        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
                        TextColor3 = Color3.fromRGB(0, 0, 0)
                    }):Play()
                end
            end
            
            Services.TweenService:Create(optionBtn, TweenInfo.new(0.2), {
                BackgroundColor3 = Config.AccentColor,
                TextColor3 = Color3.fromRGB(255, 255, 255)
            }):Play()
            
            isOpen = false
            Services.TweenService:Create(optionsFrame, TweenInfo.new(0.2), {
                Size = UDim2.new(0.6, -16, 0, 0)
            }):Play()
            wait(0.2)
            optionsFrame.Visible = false
        end)
        addToCleanup("Connections", optionClickConnection)
    end
    
    return dropdownFrame
end

local espColorPalette = {
    Color3.fromRGB(0, 122, 255),
    Color3.fromRGB(52, 199, 89),
    Color3.fromRGB(255, 59, 48),
    Color3.fromRGB(255, 149, 0),
    Color3.fromRGB(175, 82, 222),
    Color3.fromRGB(255, 45, 85),
    Color3.fromRGB(90, 200, 250),
    Color3.fromRGB(255, 204, 0)
}

local function createColorPicker(name, order, defaultColor, callback, isESP)
    local pickerFrame = Instance.new("Frame")
    pickerFrame.Size = UDim2.new(0, scrollFrame.AbsoluteSize.X - 12, 0, isESP and 100 or 100)
    pickerFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    pickerFrame.BorderSizePixel = 0
    pickerFrame.BackgroundTransparency = 0.3
    pickerFrame.LayoutOrder = order
    pickerFrame.Parent = scrollFrame
    
    local pickerCorner = Instance.new("UICorner", pickerFrame)
    pickerCorner.CornerRadius = UDim.new(0, 16)
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.65, 0, 0, 30)
    label.Position = UDim2.new(0, 16, 0, 10)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(0, 0, 0)
    label.TextSize = 15
    label.Font = Enum.Font.Gotham
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = pickerFrame
    
    local colorGrid = Instance.new("Frame")
    colorGrid.Size = UDim2.new(1, -32, 0, 50)
    colorGrid.Position = UDim2.new(0, 16, 0, 40)
    colorGrid.BackgroundTransparency = 1
    colorGrid.Parent = pickerFrame
    
    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = UDim2.new(0, 35, 0, 35)
    gridLayout.CellPadding = UDim2.new(0, 10, 0, 10)
    gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    gridLayout.Parent = colorGrid
    
    for _, color in ipairs(espColorPalette) do
        local colorBtn = Instance.new("TextButton")
        colorBtn.Size = UDim2.new(0, 35, 0, 35)
        colorBtn.BackgroundColor3 = color
        colorBtn.Text = ""
        colorBtn.BorderSizePixel = 0
        colorBtn.Parent = colorGrid
        
        local colorBtnCorner = Instance.new("UICorner", colorBtn)
        colorBtnCorner.CornerRadius = UDim.new(1, 0)
        
        local selected = Instance.new("UIStroke", colorBtn)
        selected.Color = Color3.fromRGB(255, 255, 255)
        selected.Thickness = 3
        selected.Transparency = color == defaultColor and 0 or 1
        
        local colorBtnConnection = colorBtn.MouseButton1Click:Connect(function()
            for _, otherBtn in ipairs(colorGrid:GetChildren()) do
                if otherBtn:IsA("TextButton") then
                    local stroke = otherBtn:FindFirstChildOfClass("UIStroke")
                    if stroke then
                        Services.TweenService:Create(stroke, TweenInfo.new(0.2), {
                            Transparency = 1
                        }):Play()
                    end
                end
            end
            
            Services.TweenService:Create(selected, TweenInfo.new(0.2), {
                Transparency = 0
            }):Play()
            
            if not isESP then
                updateGUIColors(color)
            end
            callback(color)
        end)
        addToCleanup("Connections", colorBtnConnection)
    end
    
    return pickerFrame
end

local function createKeybindPicker(name, order, defaultKey, callback)
    local keybindFrame = Instance.new("Frame")
    keybindFrame.Name = "KeybindFrame"
    keybindFrame.Size = UDim2.new(0, scrollFrame.AbsoluteSize.X - 12, 0, 52)
    keybindFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    keybindFrame.BorderSizePixel = 0
    keybindFrame.BackgroundTransparency = 0.3
    keybindFrame.LayoutOrder = order
    keybindFrame.Parent = scrollFrame
    
    local keybindCorner = Instance.new("UICorner", keybindFrame)
    keybindCorner.CornerRadius = UDim.new(0, 16)
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.5, 0, 1, 0)
    label.Position = UDim2.new(0, 16, 0, 0)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(0, 0, 0)
    label.TextSize = 15
    label.Font = Enum.Font.Gotham
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = keybindFrame
    
    local keybindBtn = Instance.new("TextButton")
    keybindBtn.Size = UDim2.new(0, 80, 0, 36)
    keybindBtn.Position = UDim2.new(1, -96, 0.5, -18)
    keybindBtn.BackgroundColor3 = Color3.fromRGB(242, 242, 247)
    keybindBtn.Text = defaultKey.Name
    keybindBtn.TextColor3 = Config.AccentColor
    keybindBtn.TextSize = 14
    keybindBtn.Font = Enum.Font.GothamMedium
    keybindBtn.BorderSizePixel = 0
    keybindBtn.Parent = keybindFrame
    
    local keybindCorner2 = Instance.new("UICorner", keybindBtn)
    keybindCorner2.CornerRadius = UDim.new(0, 10)
    
    local listening = false
    
    local keybindBtnConnection = keybindBtn.MouseButton1Click:Connect(function()
        listening = true
        keybindBtn.Text = "..."
        keybindBtn.TextColor3 = Color3.fromRGB(255, 149, 0)
        
        local connection
        connection = Services.UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end
            
            if input.UserInputType == Enum.UserInputType.Keyboard then
                listening = false
                keybindBtn.Text = input.KeyCode.Name
                keybindBtn.TextColor3 = Config.AccentColor
                callback(input.KeyCode)
                connection:Disconnect()
            end
        end)
        addToCleanup("Connections", connection)
    end)
    addToCleanup("Connections", keybindBtnConnection)
    
    return keybindFrame
end

local shutdownBtn = Instance.new("TextButton")
shutdownBtn.Size = UDim2.new(0, scrollFrame.AbsoluteSize.X - 12, 0, 55)
shutdownBtn.Position = UDim2.new(0, 0, 0, 0)
shutdownBtn.BackgroundColor3 = Color3.fromRGB(255, 59, 48)
shutdownBtn.Text = "Shutdown Script"
shutdownBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
shutdownBtn.TextSize = 17
shutdownBtn.Font = Enum.Font.GothamBold
shutdownBtn.BorderSizePixel = 0
shutdownBtn.BackgroundTransparency = 0.15
shutdownBtn.LayoutOrder = 999
shutdownBtn.Parent = scrollFrame

local shutdownCorner = Instance.new("UICorner", shutdownBtn)
shutdownCorner.CornerRadius = UDim.new(0, 16)

local shutdownConnection = shutdownBtn.MouseButton1Click:Connect(function()
    shutdownBtn.Text = "Shutting down..."
    shutdownBtn.BackgroundColor3 = Color3.fromRGB(200, 40, 30)
    
    scriptEnabled = false
    Config.Enabled = false
    Config.ESP.Enabled = false
    isSpeedEnabled = false
    
    FOVCircle.Visible = false
    TargetIndicator.Visible = false
    MultipointCircle.Visible = false
    
    for player, esp in pairs(ESPObjects) do
        removeESP(player)
    end
    
    wait(0.5)
    
    Services.TweenService:Create(mainFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
        Size = UDim2.new(0, 0, 0, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0)
    }):Play()
    
    Services.TweenService:Create(blurEffect, TweenInfo.new(0.4), {
        Size = 0
    }):Play()
    
    wait(0.5)
    
    -- FULL CLEANUP
    performFullCleanup()
    
    wait(0.1)
    gui:Destroy()
end)
addToCleanup("Connections", shutdownConnection)

createModuleSection("Combat", 1)

local gridContainer1 = Instance.new("Frame")
gridContainer1.Size = UDim2.new(0, scrollFrame.AbsoluteSize.X - 12, 0, 290)
gridContainer1.BackgroundTransparency = 1
gridContainer1.LayoutOrder = 2
gridContainer1.Parent = scrollFrame

local gridLayout1 = Instance.new("UIGridLayout")
gridLayout1.CellSize = UDim2.new(0, 120, 0, 135)
gridLayout1.CellPadding = UDim2.new(0, 15, 0, 15)
gridLayout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
gridLayout1.Parent = gridContainer1

createCircleButton("Silent Aim", 1, Config.Enabled, function(value)
    Config.Enabled = value
end).Parent = gridContainer1

createCircleButton("Team Check", 2, Config.TeamCheck, function(value)
    Config.TeamCheck = value
end).Parent = gridContainer1

createCircleButton("Wall Check", 3, Config.WallCheck, function(value)
    Config.WallCheck = value
end).Parent = gridContainer1

createCircleButton("Show FOV", 4, Config.ShowFOV, function(value)
    Config.ShowFOV = value
end).Parent = gridContainer1

createCircleButton("Resolver", 5, Config.Resolver, function(value)
    Config.Resolver = value
end).Parent = gridContainer1

createCircleButton("Multipoint", 6, Config.Multipoint, function(value)
    Config.Multipoint = value
    if value then
        MultipointCircle.Visible = Config.ShowFOV
    else
        MultipointCircle.Visible = false
    end
end).Parent = gridContainer1

createCircleButton("KO Check", 7, Config.KnockedCheck, function(value)
    Config.KnockedCheck = value
end).Parent = gridContainer1

createModuleSection("Combat Settings", 3)

createModernSlider("FOV Size", 4, 20, 500, Config.FOVSize, function(value)
    Config.FOVSize = value
end, false)

createModernSlider("Max Distance", 5, 100, 1000, Config.MaxDistance, function(value)
    Config.MaxDistance = value
    Config.CurrentMaxDistance = value
end, false)

createModernSlider("Multipoint Size", 6, 1, 10, Config.MultipointSize, function(value)
    Config.MultipointSize = value
end, true)

createDropdown("Target Part", 7, {
    "Head",
    "UpperTorso",
    "Closest Point",
    "LowerTorso",
    "HumanoidRootPart",
    "LeftUpperArm",
    "LeftLowerArm",
    "LeftHand",
    "RightUpperArm",
    "RightLowerArm",
    "RightHand",
    "LeftUpperLeg",
    "LeftLowerLeg",
    "LeftFoot",
    "RightUpperLeg",
    "RightLowerLeg",
    "RightFoot",
}, Config.HitPart, function(value)
    Config.HitPart = value
    cachedTarget = nil
    cachedTargetPoint = nil
end)

createKeybindPicker("Silent Aim Key", 8, Config.Keybind, function(key)
    Config.Keybind = key
end)

createModuleSection("Rapid Fire", 9)

createCompactToggle("Rapid Fire", 10, Config.RapidFire, function(value)
    Config.RapidFire = value
    setupRapidFire()
end)

createModernSlider("Fire Delay", 11, 0.01, 0.5, Config.RapidFireDelay, function(value)
    Config.RapidFireDelay = value
end, true)

createModuleSection("Spread Modifier", 12)

createCompactToggle("Reduce Spread", 13, SpreadMod.BulletSpread.Enabled, function(value)
    SpreadMod.BulletSpread.Enabled = value
end)

createModernSlider("Spread Amount", 14, 0, 100, SpreadMod.BulletSpread.Amount, function(value)
    SpreadMod.BulletSpread.Amount = value
end, false)

createModuleSection("Walk Speed", 15)

createCompactToggle("Speed Enabled", 16, isSpeedEnabled, function(value)
    isSpeedEnabled = value
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        saveOriginalSpeed()
        updateSpeed()
    end
end)

createModernSlider("Walk Speed", 17, 16, 500, currentWalkSpeed, function(value)
    currentWalkSpeed = value
    if isSpeedEnabled then
        updateSpeed()
    end
end, false)

createKeybindPicker("Speed Toggle Key", 18, currentSpeedKeybind, function(key)
    currentSpeedKeybind = key
end)

createModuleSection("ESP Settings", 19)

local gridContainer2 = Instance.new("Frame")
gridContainer2.Size = UDim2.new(0, scrollFrame.AbsoluteSize.X - 12, 0, 290)
gridContainer2.BackgroundTransparency = 1
gridContainer2.LayoutOrder = 20
gridContainer2.Parent = scrollFrame

local gridLayout2 = Instance.new("UIGridLayout")
gridLayout2.CellSize = UDim2.new(0, 120, 0, 135)
gridLayout2.CellPadding = UDim2.new(0, 15, 0, 15)
gridLayout2.HorizontalAlignment = Enum.HorizontalAlignment.Center
gridLayout2.Parent = gridContainer2

createCircleButton("ESP", 1, Config.ESP.Enabled, function(value)
    Config.ESP.Enabled = value
end).Parent = gridContainer2

createCircleButton("Box", 2, Config.ESP.ShowBox, function(value)
    Config.ESP.ShowBox = value
end).Parent = gridContainer2

createCircleButton("Name", 3, Config.ESP.ShowName, function(value)
    Config.ESP.ShowName = value
end).Parent = gridContainer2

createCircleButton("Distance", 4, Config.ESP.ShowDistance, function(value)
    Config.ESP.ShowDistance = value
end).Parent = gridContainer2

createCircleButton("Health", 5, Config.ESP.ShowHealth, function(value)
    Config.ESP.ShowHealth = value
end).Parent = gridContainer2

createCircleButton("Skeleton", 6, Config.ESP.ShowSkeleton, function(value)
    Config.ESP.ShowSkeleton = value
end).Parent = gridContainer2

createModuleSection("ESP Colors", 21)

createColorPicker("Box Color", 22, Config.ESP.BoxColor, function(color)
    Config.ESP.BoxColor = color
end, true)

createColorPicker("Name Color", 23, Config.ESP.NameColor, function(color)
    Config.ESP.NameColor = color
end, true)

createColorPicker("Distance Color", 24, Config.ESP.DistanceColor, function(color)
    Config.ESP.DistanceColor = color
end, true)

createColorPicker("Skeleton Color", 25, Config.ESP.SkeletonColor, function(color)
    Config.ESP.SkeletonColor = color
end, true)

createModernSlider("ESP Distance", 26, 100, 1000, Config.ESP.MaxDistance, function(value)
    Config.ESP.MaxDistance = value
end, false)

createCompactToggle("ESP Team Check", 27, Config.ESP.TeamCheck, function(value)
    Config.ESP.TeamCheck = value
end)

createModuleSection("GUI Settings", 28)

createColorPicker("GUI Accent Color", 29, Config.AccentColor, function(color)
    updateGUIColors(color)
end, false)

createKeybindPicker("Toggle GUI", 30, Config.GUIToggleKey, function(key)
    Config.GUIToggleKey = key
end)

createCompactToggle("Show Targeting", 31, Config.ShowTargeting, function(value)
    Config.ShowTargeting = value
end)

local guiToggleConnection = Services.UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Config.GUIToggleKey then
        mainFrame.Visible = not mainFrame.Visible
        
        if mainFrame.Visible then
            mainFrame.Size = UDim2.new(0, 0, 0, 0)
            mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
            
            Services.TweenService:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.new(0, Config.GUISize.Width, 0, Config.GUISize.Height),
                Position = UDim2.new(0.5, -Config.GUISize.Width/2, 0.5, -Config.GUISize.Height/2)
            }):Play()
            
            Services.TweenService:Create(blurEffect, TweenInfo.new(0.3), {
                Size = 15
            }):Play()
        else
            Services.TweenService:Create(mainFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
                Size = UDim2.new(0, 0, 0, 0),
                Position = UDim2.new(0.5, 0, 0.5, 0)
            }):Play()
            
            Services.TweenService:Create(blurEffect, TweenInfo.new(0.3), {
                Size = 0
            }):Play()
        end
    end
end)
addToCleanup("Connections", guiToggleConnection)

wait(0.5)
mainFrame.Visible = true
mainFrame.Size = UDim2.new(0, 0, 0, 0)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)

Services.TweenService:Create(mainFrame, TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
    Size = UDim2.new(0, Config.GUISize.Width, 0, Config.GUISize.Height),
    Position = UDim2.new(0.5, -Config.GUISize.Width/2, 0.5, -Config.GUISize.Height/2)
}):Play()

Services.TweenService:Create(blurEffect, TweenInfo.new(0.4), {
    Size = 15
}):Play()

end

-- ════════════════════════════════════════════════════════════════
-- INITIALIZATION
-- ════════════════════════════════════════════════════════════════

createAuthGUI()
