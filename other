    CurrentWeapon = nil,
    CurrentPrediction = Vector3.new(0, 0, 0),
    CurrentMaxDistance = 400,
    
    -- ESP Settings
    ESP = {
        Enabled = true,
        ShowBox = true,
        ShowName = true,
        ShowDistance = true,
        ShowHealth = true,
        ShowSkeleton = true,
        BoxColor = Color3.fromRGB(255, 255, 255),
        NameColor = Color3.fromRGB(255, 255, 255),
        DistanceColor = Color3.fromRGB(200, 200, 200),
        HealthBarColor = Color3.fromRGB(0, 255, 0),
        SkeletonColor = Color3.fromRGB(255, 255, 255),
        MaxDistance = 500,
        TeamCheck = true
    }
}

local SpreadMod = {
    BulletSpread = {
        Enabled = true,
        Amount = 70
    }
}

local allBodyParts = {
    "Head",
    "UpperTorso",
    "LowerTorso",
    "HumanoidRootPart",
    "LeftUpperArm",
    "LeftLowerArm",
    "LeftHand",
    "RightUpperArm",
    "RightLowerArm",
    "RightHand",
    "LeftUpperLeg",
    "LeftLowerLeg",
    "LeftFoot",
    "RightUpperLeg",
    "RightLowerLeg",
    "RightFoot"
}

local skeletonConnections = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"}
}

local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 2
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Transparency = 1
FOVCircle.NumSides = 24
FOVCircle.Filled = false

local TargetIndicator = Drawing.new("Circle")
TargetIndicator.Visible = false
TargetIndicator.Thickness = 3
TargetIndicator.Color = Color3.fromRGB(255, 0, 0)
TargetIndicator.Transparency = 1
TargetIndicator.NumSides = 16
TargetIndicator.Radius = 8
TargetIndicator.Filled = false

local MultipointCircle = Drawing.new("Circle")
MultipointCircle.Visible = false
MultipointCircle.Thickness = 1
MultipointCircle.Color = Color3.fromRGB(0, 255, 255)
MultipointCircle.Transparency = 0.5
MultipointCircle.NumSides = 12
MultipointCircle.Radius = 5
MultipointCircle.Filled = false

local cachedTarget = nil
local cachedTargetPoint = nil
local lastShotTime = 0
local rapidFireConnection = nil

local playerCache = {}
local lastCacheUpdate = 0
local CACHE_UPDATE_INTERVAL = 1

local mouseLocation = Vector2.new(0, 0)
local lastMouseUpdate = 0

local currentWeaponCache = nil
local lastWeaponCheck = 0
local WEAPON_CHECK_INTERVAL = 0.2

local ESPObjects = {}

local function createESP(player)
    if ESPObjects[player] then return end
    
    local esp = {
        Box = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthBar = Drawing.new("Square"),
        HealthBarOutline = Drawing.new("Square"),
        SkeletonLines = {}
    }
    
    for i = 1, #skeletonConnections do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Thickness = 2
        line.Transparency = 1
        table.insert(esp.SkeletonLines, line)
    end
    
    esp.Box.Visible = false
    esp.Box.Thickness = 2
    esp.Box.Filled = false
    esp.Box.Transparency = 1
    
    esp.Name.Visible = false
    esp.Name.Center = true
    esp.Name.Outline = true
    esp.Name.Size = 14
    esp.Name.Font = 2
    
    esp.Distance.Visible = false
    esp.Distance.Center = true
    esp.Distance.Outline = true
    esp.Distance.Size = 13
    esp.Distance.Font = 2
    
    esp.HealthBar.Visible = false
    esp.HealthBar.Filled = true
    esp.HealthBar.Thickness = 1
    
    esp.HealthBarOutline.Visible = false
    esp.HealthBarOutline.Filled = false
    esp.HealthBarOutline.Thickness = 1
    esp.HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
    
    ESPObjects[player] = esp
end

local function removeESP(player)
    if ESPObjects[player] then
        for _, drawing in pairs(ESPObjects[player]) do
            if type(drawing) == "table" then
                for _, line in pairs(drawing) do
                    line:Remove()
                end
            else
                drawing:Remove()
            end
        end
        ESPObjects[player] = nil
    end
end

local function updateESP()
    if not Config.ESP.Enabled then
        for _, esp in pairs(ESPObjects) do
            for key, drawing in pairs(esp) do
                if key == "SkeletonLines" then
                    for _, line in pairs(drawing) do
                        line.Visible = false
                    end
                else
                    drawing.Visible = false
                end
            end
        end
        return
    end
    
    for player, esp in pairs(ESPObjects) do
        if player and player.Character and player ~= LocalPlayer then
            local character = player.Character
            local hrp = character:FindFirstChild("HumanoidRootPart")
            local head = character:FindFirstChild("Head")
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            
            if hrp and head and humanoid and humanoid.Health > 0 then
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                
                if distance <= Config.ESP.MaxDistance then
                    if Config.ESP.TeamCheck and LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team then
                        for key, drawing in pairs(esp) do
                            if key == "SkeletonLines" then
                                for _, line in pairs(drawing) do
                                    line.Visible = false
                                end
                            else
                                drawing.Visible = false
                            end
                        end
                    else
                        local vector, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                        
                        if onScreen then
                            local headPos = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
                            local legPos = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0))
                            
                            local height = math.abs(headPos.Y - legPos.Y)
                            local width = height / 2
                            
                            if Config.ESP.ShowBox then
                                esp.Box.Visible = true
                                esp.Box.Size = Vector2.new(width, height)
                                esp.Box.Position = Vector2.new(vector.X - width / 2, vector.Y - height / 2)
                                esp.Box.Color = Config.ESP.BoxColor
                            else
                                esp.Box.Visible = false
                            end
                            
                            if Config.ESP.ShowName then
                                esp.Name.Visible = true
                                esp.Name.Text = player.Name
                                esp.Name.Position = Vector2.new(vector.X, headPos.Y - 20)
                                esp.Name.Color = Config.ESP.NameColor
                            else
                                esp.Name.Visible = false
                            end
                            
                            if Config.ESP.ShowDistance then
                                esp.Distance.Visible = true
                                esp.Distance.Text = math.floor(distance) .. "m"
                                esp.Distance.Position = Vector2.new(vector.X, legPos.Y + 5)
                                esp.Distance.Color = Config.ESP.DistanceColor
                            else
                                esp.Distance.Visible = false
                            end
                            
                            if Config.ESP.ShowHealth then
                                local healthPercent = humanoid.Health / humanoid.MaxHealth
                                
                                esp.HealthBarOutline.Visible = true
                                esp.HealthBarOutline.Size = Vector2.new(4, height + 2)
                                esp.HealthBarOutline.Position = Vector2.new(vector.X - width / 2 - 8, vector.Y - height / 2 - 1)
                                
                                esp.HealthBar.Visible = true
                                esp.HealthBar.Size = Vector2.new(2, height * healthPercent)
                                esp.HealthBar.Position = Vector2.new(vector.X - width / 2 - 7, vector.Y + height / 2 - height * healthPercent)
                                esp.HealthBar.Color = Color3.fromRGB(
                                    math.clamp(255 * (1 - healthPercent), 0, 255),
                                    math.clamp(255 * healthPercent, 0, 255),
                                    0
                                )
                            else
                                esp.HealthBar.Visible = false
                                esp.HealthBarOutline.Visible = false
                            end
                            
                            if Config.ESP.ShowSkeleton then
                                for i, connection in ipairs(skeletonConnections) do
                                    local part1 = character:FindFirstChild(connection[1])
                                    local part2 = character:FindFirstChild(connection[2])
                                    
                                    if part1 and part2 and esp.SkeletonLines[i] then
                                        local pos1, vis1 = Camera:WorldToViewportPoint(part1.Position)
                                        local pos2, vis2 = Camera:WorldToViewportPoint(part2.Position)
                                        
                                        if vis1 and vis2 then
                                            esp.SkeletonLines[i].Visible = true
                                            esp.SkeletonLines[i].From = Vector2.new(pos1.X, pos1.Y)
                                            esp.SkeletonLines[i].To = Vector2.new(pos2.X, pos2.Y)
                                            esp.SkeletonLines[i].Color = Config.ESP.SkeletonColor
                                        else
                                            esp.SkeletonLines[i].Visible = false
                                        end
                                    elseif esp.SkeletonLines[i] then
                                        esp.SkeletonLines[i].Visible = false
                                    end
                                end
                            else
                                for _, line in pairs(esp.SkeletonLines) do
                                    line.Visible = false
                                end
                            end
                        else
                            for key, drawing in pairs(esp) do
                                if key == "SkeletonLines" then
                                    for _, line in pairs(drawing) do
                                        line.Visible = false
                                    end
                                else
                                    drawing.Visible = false
                                end
                            end
                        end
                    end
                else
                    for key, drawing in pairs(esp) do
                        if key == "SkeletonLines" then
                            for _, line in pairs(drawing) do
                                line.Visible = false
                            end
                        else
                            drawing.Visible = false
                        end
                    end
                end
            else
                for key, drawing in pairs(esp) do
                    if key == "SkeletonLines" then
                        for _, line in pairs(drawing) do
                            line.Visible = false
                        end
                    else
                        drawing.Visible = false
                    end
                end
            end
        else
            for key, drawing in pairs(esp) do
                if key == "SkeletonLines" then
                    for _, line in pairs(drawing) do
                        line.Visible = false
                    end
                else
                    drawing.Visible = false
                end
            end
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)

Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createESP(player)
    end
end

local function getCurrentWeapon()
    local now = tick()
    if now - lastWeaponCheck < WEAPON_CHECK_INTERVAL and currentWeaponCache then
        return currentWeaponCache
    end
    
    lastWeaponCheck = now
    local character = LocalPlayer.Character
    if not character then 
        currentWeaponCache = nil
        return nil 
    end
    
    local tool = character:FindFirstChildOfClass("Tool")
    currentWeaponCache = tool and tool.Name or nil
    return currentWeaponCache
end

local function updateWeaponSettings()
    local weaponName = getCurrentWeapon()
    if not weaponName then 
        Config.CurrentWeapon = nil
        return 
    end
    
    if Config.CurrentWeapon == weaponName then return end
    
    local profile = Config.WeaponProfiles[weaponName] or Config.WeaponProfiles["Default"]
    
    Config.CurrentWeapon = weaponName
    Config.CurrentPrediction = profile.Prediction
    Config.CurrentMaxDistance = profile.MaxDistance
end

local teamCheckCache = {}
local function isOnSameTeam(player)
    if not Config.TeamCheck then return false end
    if not LocalPlayer.Team or not player.Team then return false end
    
    local cacheKey = player.UserId
    local now = tick()
    
    if teamCheckCache[cacheKey] and now - teamCheckCache[cacheKey].time < 2 then
        return teamCheckCache[cacheKey].result
    end
    
    local result = LocalPlayer.Team == player.Team
    teamCheckCache[cacheKey] = {result = result, time = now}
    return result
end

local knockedCache = {}
local function isKnocked(player)
    if not Config.KnockedCheck then return false end
    
    local cacheKey = player.UserId
    local now = tick()
    
    if knockedCache[cacheKey] and now - knockedCache[cacheKey].time < 0.5 then
        return knockedCache[cacheKey].result
    end
    
    local character = player.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then
        knockedCache[cacheKey] = {result = true, time = now}
        return true
    end
    
    local bodyEffects = character:FindFirstChild("BodyEffects")
    local result = false
    if bodyEffects then
        local knocked = bodyEffects:FindFirstChild("K.O")
        if knocked and knocked.Value == true then
            result = true
        end
    end
    
    knockedCache[cacheKey] = {result = result, time = now}
    return result
end

local wallCheckCache = {}
local function hasWallBetween(origin, targetPart)
    if not Config.WallCheck then return false end
    
    local cacheKey = tostring(targetPart)
    local now = tick()
    
    if wallCheckCache[cacheKey] and now - wallCheckCache[cacheKey].time < 0.2 then
        return wallCheckCache[cacheKey].result
    end
    
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.IgnoreWater = true
    
    local direction = (targetPart.Position - origin)
    local rayResult = workspace:Raycast(origin, direction, rayParams)
    
    local result = false
    if rayResult and rayResult.Instance then
        if not rayResult.Instance:IsDescendantOf(targetPart.Parent) then
            result = true
        end
    end
    
    wallCheckCache[cacheKey] = {result = result, time = now}
    return result
end

local function isVisible(part)
    if not Config.VisibleCheck then return true end
    
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    
    return not hasWallBetween(Camera.CFrame.Position, part)
end

local function resolveVelocity(part)
    if not Config.Resolver then
        return part.Velocity
    end
    
    local velocity = part.Velocity
    local magnitude = velocity.Magnitude
    
    if magnitude < 5 then
        return Vector3.new(0, 0, 0)
    end
    
    if velocity.Y > 10 or velocity.Y < -10 then
        velocity = Vector3.new(velocity.X, velocity.Y * 0.7, velocity.Z)
    end
    
    if magnitude > 80 then
        velocity = velocity * 0.5
    end
    
    return velocity
end

local function getClosestPointOnPart(part, mousePos)
    if not Config.Multipoint then
        return part.Position
    end
    
    local size = part.Size
    local cf = part.CFrame
    local multipointSize = Config.MultipointSize / 10
    
    local points = {
        part.Position,
        (cf * CFrame.new(size.X * multipointSize, 0, 0)).Position,
        (cf * CFrame.new(-size.X * multipointSize, 0, 0)).Position,
        (cf * CFrame.new(0, size.Y * multipointSize, 0)).Position,
        (cf * CFrame.new(0, -size.Y * multipointSize, 0)).Position,
        (cf * CFrame.new(0, 0, size.Z * multipointSize)).Position,
        (cf * CFrame.new(0, 0, -size.Z * multipointSize)).Position,
        (cf * CFrame.new(size.X * multipointSize, size.Y * multipointSize, 0)).Position,
        (cf * CFrame.new(-size.X * multipointSize, size.Y * multipointSize, 0)).Position,
        (cf * CFrame.new(size.X * multipointSize, -size.Y * multipointSize, 0)).Position,
    }
    
    local closestPoint = part.Position
    local closestDist = math.huge
    
    for _, point in ipairs(points) do
        local screenPos, onScreen = Camera:WorldToViewportPoint(point)
        if onScreen then
            local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestPoint = point
            end
        end
    end
    
    return closestPoint
end

local function getClosestPart(character)
    if not character then return nil, nil end
    
    if Config.HitPart ~= "Closest Point" then
        local part = character:FindFirstChild(Config.HitPart)
        if part and part:IsA("BasePart") then
            local hitPoint = getClosestPointOnPart(part, mouseLocation)
            return part, hitPoint
        end
    end
    
    local bestPart, bestPoint, bestDist = nil, nil, math.huge
    
    for _, partName in ipairs(allBodyParts) do
        local part = character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            local hitPoint = getClosestPointOnPart(part, mouseLocation)
            local screenPos, onScreen = Camera:WorldToViewportPoint(hitPoint)
            
            if onScreen then
                local partPos = Vector2.new(screenPos.X, screenPos.Y)
                local dist = (mouseLocation - partPos).Magnitude
                
                if dist < bestDist then
                    bestPart = part
                    bestPoint = hitPoint
                    bestDist = dist
                end
            end
        end
    end
    
    return bestPart, bestPoint
end

local function updatePlayerCache()
    local now = tick()
    if now - lastCacheUpdate < CACHE_UPDATE_INTERVAL then return end
    lastCacheUpdate = now
    
    playerCache = {}
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myPos then return end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (myPos.Position - player.Character.HumanoidRootPart.Position).Magnitude
            
            if distance <= Config.CurrentMaxDistance * 1.3 then
                table.insert(playerCache, {
                    player = player,
                    distance = distance
                })
            end
        end
    end
    
    table.sort(playerCache, function(a, b) return a.distance < b.distance end)
end

local function updateTarget()
    updateWeaponSettings()
    updatePlayerCache()
    
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then 
        cachedTarget = nil
        cachedTargetPoint = nil
        return 
    end
    
    local fovRadius = Config.FOVSize
    local bestPart, bestPoint, bestDist = nil, nil, math.huge
    
    local playersToCheck = math.min(#playerCache, Config.MaxPlayersToCheck)
    
    for i = 1, playersToCheck do
        local data = playerCache[i]
        local player = data.player
        
        if Config.TeamCheck and isOnSameTeam(player) then continue end
        if Config.KnockedCheck and isKnocked(player) then continue end
        
        local part, hitPoint = getClosestPart(player.Character)
        
        if part and hitPoint then
            local screenPos, onScreen = Camera:WorldToViewportPoint(hitPoint)
            if not onScreen then continue end
            
            local partPos = Vector2.new(screenPos.X, screenPos.Y)
            local distFromMouse = (mouseLocation - partPos).Magnitude
            
            if distFromMouse <= fovRadius then
                if Config.WallCheck and hasWallBetween(Camera.CFrame.Position, part) then 
                    continue 
                end
                
                if distFromMouse < bestDist then
                    bestPart = part
                    bestPoint = hitPoint
                    bestDist = distFromMouse
                end
            end
        end
    end
    
    cachedTarget = bestPart
    cachedTargetPoint = bestPoint
end

local function applyPrediction(position, velocity, offset)
    return position + velocity * offset
end

local uiUpdateCounter = 0
local UI_UPDATE_RATE = 3

RunService.RenderStepped:Connect(function()
    mouseLocation = UserInputService:GetMouseLocation()
    
    uiUpdateCounter = uiUpdateCounter + 1
    
    if uiUpdateCounter % UI_UPDATE_RATE == 0 then
        FOVCircle.Position = mouseLocation
        FOVCircle.Radius = Config.FOVSize
        FOVCircle.Visible = Config.ShowFOV
        
        if Config.Multipoint then
            MultipointCircle.Position = mouseLocation
            MultipointCircle.Radius = Config.MultipointSize
            MultipointCircle.Visible = Config.ShowFOV
        else
            MultipointCircle.Visible = false
        end
        
        if Config.ShowTargeting and cachedTarget and cachedTargetPoint and Config.Enabled then
            local velocity = resolveVelocity(cachedTarget)
            local predictedPos = applyPrediction(cachedTargetPoint, velocity, Config.CurrentPrediction.X)
            local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
            
            if onScreen then
                TargetIndicator.Position = Vector2.new(screenPos.X, screenPos.Y)
                TargetIndicator.Visible = true
                TargetIndicator.Color = Color3.fromRGB(255, 0, 0)
                TargetIndicator.Radius = 8
            else
                TargetIndicator.Visible = false
            end
        else
            TargetIndicator.Visible = false
        end
    end
    
    updateESP()
end)

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Config.Keybind then
        Config.Enabled = not Config.Enabled
        print("Silent Aimbot is now", Config.Enabled and "Enabled" or "Disabled")
    end
end)

local mt = getrawmetatable(game)
local oldIndex = mt.__index
setreadonly(mt, false)
mt.__index = newcclosure(function(obj, prop)
    if Config.Enabled and obj:IsA("Mouse") and (prop == "Hit" or prop == "Target") then
        if cachedTarget and cachedTargetPoint then
            local velocity = resolveVelocity(cachedTarget)
            local predictedPos = applyPrediction(cachedTargetPoint, velocity, Config.CurrentPrediction.X)
            
            return prop == "Hit" and CFrame.new(predictedPos) or cachedTarget
        end
    end
    return oldIndex(obj, prop)
end)
setreadonly(mt, true)

local frameCounter = 0
RunService.RenderStepped:Connect(function()
    if not Config.Enabled then return end
    frameCounter = frameCounter + 1
    if frameCounter % Config.UpdateRate == 0 then
        updateTarget()
    end
end)

local function setupRapidFire()
    if rapidFireConnection then
        rapidFireConnection:Disconnect()
        rapidFireConnection = nil
    end
    
    if not Config.RapidFire then return end
    
    rapidFireConnection = UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local shooting = true
            
            local connection
            connection = UserInputService.InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    shooting = false
                    connection:Disconnect()
                end
            end)
            
            while shooting and Config.RapidFire and Config.Enabled do
                local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if currentTool then
                    currentTool:Activate()
                end
                wait(Config.RapidFireDelay)
            end
        end
    end)
end

setupRapidFire()

local oldRandom
oldRandom = hookfunction(math.random, function(...)
    local args = {...}
    if checkcaller() then return oldRandom(...) end
    if (#args == 0) or (args[1] == -0.05 and args[2] == 0.05) or (args[1] == -0.1) or (args[1] == -0.05) then
        if SpreadMod.BulletSpread.Enabled then
            return oldRandom(...) * (SpreadMod.BulletSpread.Amount / 100)
        end
    end
    return oldRandom(...)
end)

Players.PlayerRemoving:Connect(function(player)
    teamCheckCache[player.UserId] = nil
    knockedCache[player.UserId] = nil
end)

-- GUI CREATION
local gui = Instance.new("ScreenGui")
gui.IgnoreGuiInset = true
gui.ResetOnSpawn = false
gui.Name = "SilentAimUI"
gui.Parent = CoreGui

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 520, 0, 650)
mainFrame.Position = UDim2.new(0.5, -260, 0.5, -325)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = gui

local mainCorner = Instance.new("UICorner", mainFrame)
mainCorner.CornerRadius = UDim.new(0, 16)

local mainStroke = Instance.new("UIStroke", mainFrame)
mainStroke.Color = Color3.fromRGB(80, 80, 120)
mainStroke.Thickness = 2
mainStroke.Transparency = 0.5

local gradient = Instance.new("UIGradient", mainFrame)
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 20, 30)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(15, 15, 20))
}
gradient.Rotation = 45

local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 50)
titleBar.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleCorner = Instance.new("UICorner", titleBar)
titleCorner.CornerRadius = UDim.new(0, 16)

local titleBarBottom = Instance.new("Frame")
titleBarBottom.Size = UDim2.new(1, 0, 0, 16)
titleBarBottom.Position = UDim2.new(0, 0, 1, -16)
titleBarBottom.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
titleBarBottom.BorderSizePixel = 0
titleBarBottom.Parent = titleBar

local titleGradient = Instance.new("UIGradient", titleBar)
titleGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 80, 200)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(80, 120, 220)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 250))
}

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -100, 1, 0)
title.Position = UDim2.new(0, 25, 0, 0)
title.Text = "SILENT AIM âœ“"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 22
title.Font = Enum.Font.GothamBold
title.BackgroundTransparency = 1
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = titleBar

local subtitle = Instance.new("TextLabel")
subtitle.Size = UDim2.new(1, -100, 0, 15)
subtitle.Position = UDim2.new(0, 25, 0, 30)
subtitle.Text = "Licensed & Activated"
subtitle.TextColor3 = Color3.fromRGB(100, 255, 100)
subtitle.TextSize = 11
subtitle.Font = Enum.Font.Gotham
subtitle.BackgroundTransparency = 1
subtitle.TextXAlignment = Enum.TextXAlignment.Left
subtitle.Parent = titleBar

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 40, 0, 40)
closeBtn.Position = UDim2.new(1, -45, 0, 5)
closeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 70)
closeBtn.Text = "X"
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.TextSize = 20
closeBtn.Font = Enum.Font.GothamBold
closeBtn.BorderSizePixel = 0
closeBtn.Parent = titleBar

local closeBtnCorner = Instance.new("UICorner", closeBtn)
closeBtnCorner.CornerRadius = UDim.new(0, 10)

local closeBtnStroke = Instance.new("UIStroke", closeBtn)
closeBtnStroke.Color = Color3.fromRGB(255, 100, 120)
closeBtnStroke.Thickness = 1

closeBtn.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
end)

closeBtn.MouseEnter:Connect(function()
    TweenService:Create(closeBtn, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(255, 70, 90)}):Play()
end)

closeBtn.MouseLeave:Connect(function()
    TweenService:Create(closeBtn, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(200, 50, 70)}):Play()
end)

local contentFrame = Instance.new("ScrollingFrame")
contentFrame.Size = UDim2.new(1, -30, 1, -70)
contentFrame.Position = UDim2.new(0, 15, 0, 60)
contentFrame.BackgroundTransparency = 1
contentFrame.BorderSizePixel = 0
contentFrame.ScrollBarThickness = 8
contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
contentFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 150)
contentFrame.Parent = mainFrame

local contentLayout = Instance.new("UIListLayout")
contentLayout.Parent = contentFrame
contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
contentLayout.Padding = UDim.new(0, 12)

contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    contentFrame.CanvasSize = UDim2.new(0, 0, 0, contentLayout.AbsoluteContentSize.Y + 20)
end)

local function createSection(name, order)
    local section = Instance.new("Frame")
    section.Size = UDim2.new(1, -10, 0, 38)
    section.BackgroundColor3 = Color3.fromRGB(30, 30, 45)
    section.BorderSizePixel = 0
    section.LayoutOrder = order
    section.Parent = contentFrame
    
    local sectionCorner = Instance.new("UICorner", section)
    sectionCorner.CornerRadius = UDim.new(0, 10)
    
    local sectionGradient = Instance.new("UIGradient", section)
    sectionGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 80)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(30, 30, 45))
    }
    sectionGradient.Rotation = 90
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -20, 1, 0)
    label.Position = UDim2.new(0, 15, 0, 0)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(200, 200, 255)
    label.TextSize = 15
    label.Font = Enum.Font.GothamBold
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = section
    
    return section
end

local function createToggle(name, order, defaultValue, callback)
    local toggle = Instance.new("Frame")
    toggle.Size = UDim2.new(1, -10, 0, 42)
    toggle.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    toggle.BorderSizePixel = 0
    toggle.LayoutOrder = order
    toggle.Parent = contentFrame
    
    local toggleCorner = Instance.new("UICorner", toggle)
    toggleCorner.CornerRadius = UDim.new(0, 10)
    
    local toggleStroke = Instance.new("UIStroke", toggle)
    toggleStroke.Color = Color3.fromRGB(50, 50, 70)
    toggleStroke.Thickness = 1
    toggleStroke.Transparency = 0.7
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -75, 1, 0)
    label.Position = UDim2.new(0, 15, 0, 0)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(200, 200, 220)
    label.TextSize = 14
    label.Font = Enum.Font.Gotham
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = toggle
    
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 50, 0, 28)
    button.Position = UDim2.new(1, -60, 0.5, -14)
    button.BackgroundColor3 = defaultValue and Color3.fromRGB(80, 200, 120) or Color3.fromRGB(60, 60, 80)
    button.Text = defaultValue and "ON" or "OFF"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 12
    button.Font = Enum.Font.GothamBold
    button.BorderSizePixel = 0
    button.Parent = toggle
    
    local buttonCorner = Instance.new("UICorner", button)
    buttonCorner.CornerRadius = UDim.new(0, 8)
    
    local buttonStroke = Instance.new("UIStroke", button)
    buttonStroke.Color = defaultValue and Color3.fromRGB(100, 255, 150) or Color3.fromRGB(80, 80, 100)
    buttonStroke.Thickness = 1.5
    
    local enabled = defaultValue
    button.MouseButton1Click:Connect(function()
        enabled = not enabled
        button.Text = enabled and "ON" or "OFF"
        
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = enabled and Color3.fromRGB(80, 200, 120) or Color3.fromRGB(60, 60, 80)
        }):Play()
        
        TweenService:Create(buttonStroke, TweenInfo.new(0.2), {
            Color = enabled and Color3.fromRGB(100, 255, 150) or Color3.fromRGB(80, 80, 100)
        }):Play()
        
        callback(enabled)
    end)
    
    button.MouseEnter:Connect(function()
        TweenService:Create(toggleStroke, TweenInfo.new(0.2), {
            Color = Color3.fromRGB(100, 100, 150),
            Transparency = 0.3
        }):Play()
    end)
    
    button.MouseLeave:Connect(function()
        TweenService:Create(toggleStroke, TweenInfo.new(0.2), {
            Color = Color3.fromRGB(50, 50, 70),
            Transparency = 0.7
        }):Play()
    end)
    
    return toggle
end

local function createSlider(name, order, min, max, defaultValue, callback, isDecimal)
    local sliderFrame = Instance.new("Frame")
    sliderFrame.Size = UDim2.new(1, -10, 0, 65)
    sliderFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    sliderFrame.BorderSizePixel = 0
    sliderFrame.LayoutOrder = order
    sliderFrame.Parent = contentFrame
    
    local sliderCorner = Instance.new("UICorner", sliderFrame)
    sliderCorner.CornerRadius = UDim.new(0, 10)
    
    local sliderStroke = Instance.new("UIStroke", sliderFrame)
    sliderStroke.Color = Color3.fromRGB(50, 50, 70)
    sliderStroke.Thickness = 1
    sliderStroke.Transparency = 0.7
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -90, 0, 25)
    label.Position = UDim2.new(0, 15, 0, 8)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(200, 200, 220)
    label.TextSize = 14
    label.Font = Enum.Font.Gotham
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = sliderFrame
    
    local valueLabel = Instance.new("TextLabel")
    valueLabel.Size = UDim2.new(0, 70, 0, 25)
    valueLabel.Position = UDim2.new(1, -80, 0, 8)
    valueLabel.Text = isDecimal and string.format("%.2f", defaultValue) or tostring(defaultValue)
    valueLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
    valueLabel.TextSize = 13
    valueLabel.Font = Enum.Font.GothamBold
    valueLabel.BackgroundTransparency = 1
    valueLabel.TextXAlignment = Enum.TextXAlignment.Right
    valueLabel.Parent = sliderFrame
    
    local sliderBg = Instance.new("Frame")
    sliderBg.Size = UDim2.new(1, -30, 0, 8)
    sliderBg.Position = UDim2.new(0, 15, 0, 45)
    sliderBg.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    sliderBg.BorderSizePixel = 0
    sliderBg.Parent = sliderFrame
    
    local sliderBgCorner = Instance.new("UICorner", sliderBg)
    sliderBgCorner.CornerRadius = UDim.new(0, 4)
    
    local sliderFill = Instance.new("Frame")
    sliderFill.Size = UDim2.new((defaultValue - min) / (max - min), 0, 1, 0)
    sliderFill.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
    sliderFill.BorderSizePixel = 0
    sliderFill.Parent = sliderBg
    
    local sliderFillCorner = Instance.new("UICorner", sliderFill)
    sliderFillCorner.CornerRadius = UDim.new(0, 4)
    
    local sliderGradient = Instance.new("UIGradient", sliderFill)
    sliderGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 80, 200)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 150, 255))
    }
    
    local dragging = false
    sliderBg.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local relX = math.clamp((input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
            
            TweenService:Create(sliderFill, TweenInfo.new(0.1), {
                Size = UDim2.new(relX, 0, 1, 0)
            }):Play()
            
            local value = min + (max - min) * relX
            if not isDecimal then
                value = math.floor(value)
            end
            
            valueLabel.Text = isDecimal and string.format("%.2f", value) or tostring(value)
            callback(value)
        end
    end)
    
    return sliderFrame
end

local function createDropdown(name, order, options, defaultValue, callback)
    local dropdownFrame = Instance.new("Frame")
    dropdownFrame.Size = UDim2.new(1, -10, 0, 42)
    dropdownFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    dropdownFrame.BorderSizePixel = 0
    dropdownFrame.LayoutOrder = order
    dropdownFrame.ClipsDescendants = false
    dropdownFrame.Parent = contentFrame
    
    local dropdownCorner = Instance.new("UICorner", dropdownFrame)
    dropdownCorner.CornerRadius = UDim.new(0, 10)
    
    local dropdownStroke = Instance.new("UIStroke", dropdownFrame)
    dropdownStroke.Color = Color3.fromRGB(50, 50, 70)
    dropdownStroke.Thickness = 1
    dropdownStroke.Transparency = 0.7
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0, 140, 1, 0)
    label.Position = UDim2.new(0, 15, 0, 0)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(200, 200, 220)
    label.TextSize = 14
    label.Font = Enum.Font.Gotham
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = dropdownFrame
    
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, -170, 0, 30)
    button.Position = UDim2.new(0, 155, 0.5, -15)
    button.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    button.Text = defaultValue
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 13
    button.Font = Enum.Font.Gotham
    button.BorderSizePixel = 0
    button.ClipsDescendants = false
    button.ZIndex = 2
    button.Parent = dropdownFrame
    
    local buttonCorner = Instance.new("UICorner", button)
    buttonCorner.CornerRadius = UDim.new(0, 8)
    
    local dropdown = Instance.new("Frame")
    dropdown.Size = UDim2.new(1, 0, 0, #options * 35)
    dropdown.Position = UDim2.new(0, 0, 1, 3)
    dropdown.BackgroundColor3 = Color3.fromRGB(30, 30, 45)
    dropdown.BorderSizePixel = 0
    dropdown.Visible = false
    dropdown.ZIndex = 10
    dropdown.Parent = button
    
    local dropdownCorner2 = Instance.new("UICorner", dropdown)
    dropdownCorner2.CornerRadius = UDim.new(0, 8)
    
    local dropdownStroke2 = Instance.new("UIStroke", dropdown)
    dropdownStroke2.Color = Color3.fromRGB(80, 80, 120)
    dropdownStroke2.Thickness = 2
    
    for i, option in ipairs(options) do
        local optBtn = Instance.new("TextButton")
        optBtn.Size = UDim2.new(1, -8, 0, 32)
        optBtn.Position = UDim2.new(0, 4, 0, (i - 1) * 35 + 2)
        optBtn.BackgroundColor3 = Color3.fromRGB(35, 35, 50)
        optBtn.Text = option
        optBtn.TextColor3 = Color3.fromRGB(200, 200, 220)
        optBtn.TextSize = 12
        optBtn.Font = Enum.Font.Gotham
        optBtn.BorderSizePixel = 0
        optBtn.ZIndex = 11
        optBtn.Parent = dropdown
        
        local optCorner = Instance.new("UICorner", optBtn)
        optCorner.CornerRadius = UDim.new(0, 6)
        
        optBtn.MouseButton1Click:Connect(function()
            button.Text = option
            dropdown.Visible = false
            callback(option)
        end)
        
        optBtn.MouseEnter:Connect(function()
            TweenService:Create(optBtn, TweenInfo.new(0.15), {
                BackgroundColor3 = Color3.fromRGB(100, 100, 180)
            }):Play()
        end)
        
        optBtn.MouseLeave:Connect(function()
            TweenService:Create(optBtn, TweenInfo.new(0.15), {
                BackgroundColor3 = Color3.fromRGB(35, 35, 50)
            }):Play()
        end)
    end
    
    button.MouseButton1Click:Connect(function()
        dropdown.Visible = not dropdown.Visible
    end)
    
    return dropdownFrame
end

local function createColorPicker(name, order, defaultColor, callback)
    local colorFrame = Instance.new("Frame")
    colorFrame.Size = UDim2.new(1, -10, 0, 42)
    colorFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    colorFrame.BorderSizePixel = 0
    colorFrame.LayoutOrder = order
    colorFrame.Parent = contentFrame
    
    local colorCorner = Instance.new("UICorner", colorFrame)
    colorCorner.CornerRadius = UDim.new(0, 10)
    
    local colorStroke = Instance.new("UIStroke", colorFrame)
    colorStroke.Color = Color3.fromRGB(50, 50, 70)
    colorStroke.Thickness = 1
    colorStroke.Transparency = 0.7
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -70, 1, 0)
    label.Position = UDim2.new(0, 15, 0, 0)
    label.Text = name
    label.TextColor3 = Color3.fromRGB(200, 200, 220)
    label.TextSize = 14
    label.Font = Enum.Font.Gotham
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = colorFrame
    
    local colorDisplay = Instance.new("TextButton")
    colorDisplay.Size = UDim2.new(0, 50, 0, 28)
    colorDisplay.Position = UDim2.new(1, -60, 0.5, -14)
    colorDisplay.BackgroundColor3 = defaultColor
    colorDisplay.Text = ""
    colorDisplay.BorderSizePixel = 0
    colorDisplay.Parent = colorFrame
    
    local displayCorner = Instance.new("UICorner", colorDisplay)
    displayCorner.CornerRadius = UDim.new(0, 8)
    
    local displayStroke = Instance.new("UIStroke", colorDisplay)
    displayStroke.Color = Color3.fromRGB(100, 100, 150)
    displayStroke.Thickness = 2
    
    local colors = {
        Color3.fromRGB(255, 255, 255),
        Color3.fromRGB(255, 0, 0),
        Color3.fromRGB(0, 255, 0),
        Color3.fromRGB(0, 0, 255),
        Color3.fromRGB(255, 255, 0),
        Color3.fromRGB(255, 0, 255),
        Color3.fromRGB(0, 255, 255)
    }
    
    local colorIndex = 1
    colorDisplay.MouseButton1Click:Connect(function()
        colorIndex = colorIndex % #colors + 1
        local newColor = colors[colorIndex]
        
        TweenService:Create(colorDisplay, TweenInfo.new(0.2), {
            BackgroundColor3 = newColor
        }):Play()
        
        callback(newColor)
    end)
    
    return colorFrame
end

-- Build GUI
local order = 1

createSection("MAIN AIMBOT", order)
order = order + 1

createToggle("Aimbot Enabled", order, Config.Enabled, function(val)
    Config.Enabled = val
end)
order = order + 1

createToggle("Rapid Fire", order, Config.RapidFire, function(val)
    Config.RapidFire = val
    setupRapidFire()
end)
order = order + 1

createSlider("Rapid Fire Delay", order, 0.01, 0.5, Config.RapidFireDelay, function(val)
    Config.RapidFireDelay = val
end, true)
order = order + 1

createToggle("Show FOV Circle", order, Config.ShowFOV, function(val)
    Config.ShowFOV = val
end)
order = order + 1

createToggle("Multipoint", order, Config.Multipoint, function(val)
    Config.Multipoint = val
end)
order = order + 1

createSlider("Multipoint Size", order, 1, 20, Config.MultipointSize, function(val)
    Config.MultipointSize = val
end)
order = order + 1

createToggle("Show Target Indicator", order, Config.ShowTargeting, function(val)
    Config.ShowTargeting = val
end)
order = order + 1

local hitPartOptions = {"Closest Point"}
for _, partName in ipairs(allBodyParts) do
    table.insert(hitPartOptions, partName)
end

createDropdown("Hit Part", order, hitPartOptions, Config.HitPart, function(val)
    Config.HitPart = val
end)
order = order + 1

createSlider("FOV Size", order, 10, 300, Config.FOVSize, function(val)
    Config.FOVSize = val
end)
order = order + 1

createSection("PROTECTION SETTINGS", order)
order = order + 1

createToggle("Resolver Anti-Desync", order, Config.Resolver, function(val)
    Config.Resolver = val
end)
order = order + 1

createToggle("Team Check", order, Config.TeamCheck, function(val)
    Config.TeamCheck = val
end)
order = order + 1

createToggle("Knocked Check", order, Config.KnockedCheck, function(val)
    Config.KnockedCheck = val
end)
order = order + 1

createToggle("Wall Check", order, Config.WallCheck, function(val)
    Config.WallCheck = val
end)
order = order + 1

createToggle("Visibility Check", order, Config.VisibleCheck, function(val)
    Config.VisibleCheck = val
end)
order = order + 1

createSection("ESP SETTINGS", order)
order = order + 1

createToggle("ESP Enabled", order, Config.ESP.Enabled, function(val)
    Config.ESP.Enabled = val
end)
order = order + 1

createToggle("Show Box", order, Config.ESP.ShowBox, function(val)
    Config.ESP.ShowBox = val
end)
order = order + 1

createToggle("Show Name", order, Config.ESP.ShowName, function(val)
    Config.ESP.ShowName = val
end)
order = order + 1

createToggle("Show Distance", order, Config.ESP.ShowDistance, function(val)
    Config.ESP.ShowDistance = val
end)
order = order + 1

createToggle("Show Health Bar", order, Config.ESP.ShowHealth, function(val)
    Config.ESP.ShowHealth = val
end)
order = order + 1

createToggle("Show Skeleton", order, Config.ESP.ShowSkeleton, function(val)
    Config.ESP.ShowSkeleton = val
end)
order = order + 1

createColorPicker("Box Color", order, Config.ESP.BoxColor, function(color)
    Config.ESP.BoxColor = color
end)
order = order + 1

createColorPicker("Name Color", order, Config.ESP.NameColor, function(color)
    Config.ESP.NameColor = color
end)
order = order + 1

createColorPicker("Skeleton Color", order, Config.ESP.SkeletonColor, function(color)
    Config.ESP.SkeletonColor = color
end)
order = order + 1

createSlider("ESP Max Distance", order, 100, 1000, Config.ESP.MaxDistance, function(val)
    Config.ESP.MaxDistance = val
end)
order = order + 1

createToggle("ESP Team Check", order, Config.ESP.TeamCheck, function(val)
    Config.ESP.TeamCheck = val
end)
order = order + 1

createSection("PERFORMANCE", order)
order = order + 1

createSlider("Update Rate Higher Better FPS", order, 1, 10, Config.UpdateRate, function(val)
    Config.UpdateRate = val
end)
order = order + 1

createSlider("Max Players to Check", order, 5, 30, Config.MaxPlayersToCheck, function(val)
    Config.MaxPlayersToCheck = val
end)
order = order + 1

createSection("SPREAD CONTROL", order)
order = order + 1

createToggle("Spread Modifier", order, SpreadMod.BulletSpread.Enabled, function(val)
    SpreadMod.BulletSpread.Enabled = val
end)
order = order + 1

createSlider("Spread Amount", order, 0, 100, SpreadMod.BulletSpread.Amount, function(val)
    SpreadMod.BulletSpread.Amount = val
end)
order = order + 1

createSection("STATUS INFO", order)
order = order + 1

local statusInfo = Instance.new("Frame")
statusInfo.Size = UDim2.new(1, -10, 0, 140)
statusInfo.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
statusInfo.BorderSizePixel = 0
statusInfo.LayoutOrder = order
statusInfo.Parent = contentFrame

local statusCorner = Instance.new("UICorner", statusInfo)
statusCorner.CornerRadius = UDim.new(0, 10)

local statusStroke = Instance.new("UIStroke", statusInfo)
statusStroke.Color = Color3.fromRGB(50, 50, 70)
statusStroke.Thickness = 1
statusStroke.Transparency = 0.7

local weaponLabel = Instance.new("TextLabel")
weaponLabel.Size = UDim2.new(1, -20, 0, 20)
weaponLabel.Position = UDim2.new(0, 15, 0, 10)
weaponLabel.Text = "Current Weapon: None"
weaponLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
weaponLabel.TextSize = 14
weaponLabel.Font = Enum.Font.GothamBold
weaponLabel.BackgroundTransparency = 1
weaponLabel.TextXAlignment = Enum.TextXAlignment.Left
weaponLabel.Parent = statusInfo

local hitPartLabel = Instance.new("TextLabel")
hitPartLabel.Size = UDim2.new(1, -20, 0, 18)
hitPartLabel.Position = UDim2.new(0, 15, 0, 35)
hitPartLabel.Text = "Hit Part: " .. Config.HitPart
hitPartLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
hitPartLabel.TextSize = 12
hitPartLabel.Font = Enum.Font.Gotham
hitPartLabel.BackgroundTransparency = 1
hitPartLabel.TextXAlignment = Enum.TextXAlignment.Left
hitPartLabel.Parent = statusInfo

local fovLabel = Instance.new("TextLabel")
fovLabel.Size = UDim2.new(1, -20, 0, 18)
fovLabel.Position = UDim2.new(0, 15, 0, 55)
fovLabel.Text = "FOV: 80"
fovLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
fovLabel.TextSize = 12
fovLabel.Font = Enum.Font.Gotham
fovLabel.BackgroundTransparency = 1
fovLabel.TextXAlignment = Enum.TextXAlignment.Left
fovLabel.Parent = statusInfo

local multipointLabel = Instance.new("TextLabel")
multipointLabel.Size = UDim2.new(1, -20, 0, 18)
multipointLabel.Position = UDim2.new(0, 15, 0, 75)
multipointLabel.Text = "Multipoint: " .. Config.MultipointSize
multipointLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
multipointLabel.TextSize = 12
multipointLabel.Font = Enum.Font.Gotham
multipointLabel.BackgroundTransparency = 1
multipointLabel.TextXAlignment = Enum.TextXAlignment.Left
multipointLabel.Parent = statusInfo

local fpsLabel = Instance.new("TextLabel")
fpsLabel.Size = UDim2.new(1, -20, 0, 18)
fpsLabel.Position = UDim2.new(0, 15, 0, 95)
fpsLabel.Text = "FPS: 60"
fpsLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
fpsLabel.TextSize = 12
fpsLabel.Font = Enum.Font.GothamBold
fpsLabel.BackgroundTransparency = 1
fpsLabel.TextXAlignment = Enum.TextXAlignment.Left
fpsLabel.Parent = statusInfo

local targetLabel = Instance.new("TextLabel")
targetLabel.Size = UDim2.new(1, -20, 0, 18)
targetLabel.Position = UDim2.new(0, 15, 0, 115)
targetLabel.Text = "Target: None"
targetLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
targetLabel.TextSize = 12
targetLabel.Font = Enum.Font.GothamBold
targetLabel.BackgroundTransparency = 1
targetLabel.TextXAlignment = Enum.TextXAlignment.Left
targetLabel.Parent = statusInfo

order = order + 1

local credits = Instance.new("TextLabel")
credits.Size = UDim2.new(1, -10, 0, 35)
credits.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
credits.BorderSizePixel = 0
credits.LayoutOrder = order
credits.Text = "Silent Aim System v2.2 Licensed"
credits.TextColor3 = Color3.fromRGB(120, 120, 150)
credits.TextSize = 12
credits.Font = Enum.Font.GothamBold
credits.Parent = contentFrame

local creditsCorner = Instance.new("UICorner", credits)
creditsCorner.CornerRadius = UDim.new(0, 10)

local lastStatusUpdate = 0
local fpsCounter = 0
local fpsDisplay = 60

RunService.Heartbeat:Connect(function(deltaTime)
    fpsCounter = fpsCounter + 1
    local now = tick()
    
    if now - lastStatusUpdate >= 1 then
        fpsDisplay = math.floor(fpsCounter / (now - lastStatusUpdate))
        fpsCounter = 0
        lastStatusUpdate = now
        
        local weapon = getCurrentWeapon()
        if weapon then
            weaponLabel.Text = "Current Weapon: " .. weapon
        else
            weaponLabel.Text = "Current Weapon: None"
        end
        
        hitPartLabel.Text = "Hit Part: " .. Config.HitPart
        fovLabel.Text = "FOV: " .. Config.FOVSize
        multipointLabel.Text = "Multipoint Size: " .. Config.MultipointSize
        
        fpsLabel.Text = "FPS: " .. fpsDisplay
        fpsLabel.TextColor3 = fpsDisplay >= 50 and Color3.fromRGB(100, 255, 100) or
                               fpsDisplay >= 30 and Color3.fromRGB(255, 200, 100) or
                               Color3.fromRGB(255, 100, 100)
        
        if cachedTarget then
            targetLabel.Text = "Target: Locked"
            targetLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        else
            targetLabel.Text = "Target: None"
            targetLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == Enum.KeyCode.Insert then
        mainFrame.Visible = not mainFrame.Visible
    end
end)

print("âœ… Silent Aim System Loaded Successfully!")

end

-- Ð—Ð°Ð¿ÑƒÑÐº GUI Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸
createAuthGUI()
